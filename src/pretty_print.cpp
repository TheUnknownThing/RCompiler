#include "ast/visitors/pretty_print.hpp"
#include "ast/nodes/expr.hpp"
#include "ast/nodes/pattern.hpp"
#include "lexer/lexer.hpp"
#include <typeinfo>

/**
 @note Pretty Print utility is fully generated by Claude 4 Sonnet in Agent mode
 */

#define RC_SAFE_ACCEPT(ptr)                                                    \
  do {                                                                         \
    if (ptr) {                                                                 \
      (ptr)->accept(*this);                                                    \
    } else {                                                                   \
      print_inline("<null>");                                                  \
    }                                                                          \
  } while (0)

namespace rc {

PrettyPrintVisitor::PrettyPrintVisitor(int indent_level)
    : indent_level_(indent_level) {}

std::string PrettyPrintVisitor::get_result() const { return output_.str(); }

void PrettyPrintVisitor::reset() {
  output_.str("");
  output_.clear();
  indent_level_ = 0;
}

void PrettyPrintVisitor::visit(BaseNode &node) {
  // Try to cast to specific node types
  if (auto *expr = dynamic_cast<NameExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<LiteralExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<PrefixExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<BinaryExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<GroupExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<IfExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<MatchExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<ReturnExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<CallExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<MethodCallExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<FieldAccessExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<UnderscoreExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<BlockExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<LoopExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<WhileExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<ArrayExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<IndexExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<TupleExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<BreakExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<ContinueExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<PathExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<QualifiedPathExpression *>(&node)) {
    visit(*expr);
  } else if (auto *stmt = dynamic_cast<BlockStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *stmt = dynamic_cast<LetStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *stmt = dynamic_cast<ExpressionStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *stmt = dynamic_cast<EmptyStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *decl = dynamic_cast<FunctionDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<ConstantItem *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<ModuleDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<StructDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<EnumDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<TraitDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<ImplDecl *>(&node)) {
    visit(*decl);
  } else if (auto *root = dynamic_cast<RootNode *>(&node)) {
    visit(*root);
  } else {
    print_line("UnknownNode");
  }
}

// Expression visitors
void PrettyPrintVisitor::visit(NameExpression &node) {
  print_inline("NameExpr(" + node.name + ")");
}

void PrettyPrintVisitor::visit(LiteralExpression &node) {
  print_inline("LiteralExpr(" + node.value + ", " + format_type(node.type) +
               ")");
}

void PrettyPrintVisitor::visit(PrefixExpression &node) {
  print_inline("PrefixExpr(");
  print_inline(format_token(node.op) + ", ");
  RC_SAFE_ACCEPT(node.right);
  print_inline(")");
}

void PrettyPrintVisitor::visit(BinaryExpression &node) {
  print_inline("BinaryExpr(");
  RC_SAFE_ACCEPT(node.left);
  print_inline(", " + format_token(node.op) + ", ");
  RC_SAFE_ACCEPT(node.right);
  print_inline(")");
}

void PrettyPrintVisitor::visit(GroupExpression &node) {
  print_inline("GroupExpr(");
  RC_SAFE_ACCEPT(node.inner);
  print_inline(")");
}

void PrettyPrintVisitor::visit(IfExpression &node) {
  print_line("IfExpr {");
  increase_indent();

  print_indent();
  print_inline("condition: ");
  RC_SAFE_ACCEPT(node.condition);
  output_ << std::endl;

  print_indent();
  print_inline("then_block: ");
  RC_SAFE_ACCEPT(node.then_block);
  output_ << std::endl;

  if (node.else_block.has_value()) {
    print_indent();
    print_inline("else_block: ");
    RC_SAFE_ACCEPT(node.else_block.value());
    output_ << std::endl;
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(CallExpression &node) {
  print_inline("CallExpr(");
  RC_SAFE_ACCEPT(node.function_name);
  print_inline(", [");
  for (size_t i = 0; i < node.arguments.size(); ++i) {
    RC_SAFE_ACCEPT(node.arguments[i]);
    if (i < node.arguments.size() - 1) {
      print_inline(", ");
    }
  }
  print_inline("])");
}

void PrettyPrintVisitor::visit(MethodCallExpression &node) {
  print_inline("MethodCallExpr(");
  RC_SAFE_ACCEPT(node.receiver);
  print_inline(", " + node.method_name.name + ", [");
  for (size_t i = 0; i < node.arguments.size(); ++i) {
    RC_SAFE_ACCEPT(node.arguments[i]);
    if (i < node.arguments.size() - 1) {
      print_inline(", ");
    }
  }
  print_inline("])");
}

void PrettyPrintVisitor::visit(FieldAccessExpression &node) {
  print_inline("FieldAccessExpr(");
  RC_SAFE_ACCEPT(node.target);
  print_inline(", " + node.field_name + ")");
}

void PrettyPrintVisitor::visit(MatchExpression &node) {
  print_line("MatchExpr {");
  increase_indent();

  print_indent();
  print_inline("scrutinee: ");
  RC_SAFE_ACCEPT(node.scrutinee);
  output_ << std::endl;

  print_line("arms: [");
  increase_indent();
  for (const auto &arm : node.arms) {
    print_line("MatchArm {");
    increase_indent();
    print_line("pattern: " + arm.pattern);
    if (arm.guard.has_value()) {
      print_indent();
      print_inline("guard: ");
      RC_SAFE_ACCEPT(arm.guard.value());
      output_ << std::endl;
    }
    print_indent();
    print_inline("body: ");
    RC_SAFE_ACCEPT(arm.body);
    output_ << std::endl;
    decrease_indent();
    print_line("}");
  }
  decrease_indent();
  print_line("]");

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ReturnExpression &node) {
  print_inline("ReturnExpr(");
  if (node.value.has_value()) {
    RC_SAFE_ACCEPT(node.value.value());
  } else {
    print_inline("None");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(UnderscoreExpression &node) {
  (void)node; // Suppress unused parameter warning
  print_inline("UnderscoreExpr");
}

void PrettyPrintVisitor::visit(BlockExpression &node) {
  print_line("BlockExpr {");
  increase_indent();

  if (!node.statements.empty()) {
    print_line("statements: [");
    increase_indent();
    for (const auto &stmt : node.statements) {
      print_indent();
      if (stmt) {
        stmt->accept(*this);
      } else {
        print_inline("<null>");
      }
      output_ << std::endl;
    }
    decrease_indent();
    print_line("]");
  }

  if (node.final_expr.has_value()) {
    print_indent();
    print_inline("final_expr: ");
    RC_SAFE_ACCEPT(node.final_expr.value());
    output_ << std::endl;
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(LoopExpression &node) {
  print_line("LoopExpr {");
  increase_indent();
  print_indent();
  print_inline("body: ");
  RC_SAFE_ACCEPT(node.body);
  output_ << std::endl;
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(WhileExpression &node) {
  print_line("WhileExpr {");
  increase_indent();
  print_indent();
  print_inline("condition: ");
  RC_SAFE_ACCEPT(node.condition);
  output_ << std::endl;
  print_indent();
  print_inline("body: ");
  RC_SAFE_ACCEPT(node.body);
  output_ << std::endl;
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ArrayExpression &node) {
  print_inline("ArrayExpr(");
  if (node.repeat.has_value()) {
    // Repeat form: [expr ; size]
    print_inline("repeat: ");
    RC_SAFE_ACCEPT(node.repeat.value().first);
    print_inline(" ; ");
    RC_SAFE_ACCEPT(node.repeat.value().second);
  } else {
    // Element list form: [e1, e2, ...]
    print_inline("elements: [");
    for (size_t i = 0; i < node.elements.size(); ++i) {
      RC_SAFE_ACCEPT(node.elements[i]);
      if (i < node.elements.size() - 1) {
        print_inline(", ");
      }
    }
    print_inline("]");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(IndexExpression &node) {
  print_inline("IndexExpr(");
  RC_SAFE_ACCEPT(node.target);
  print_inline("[");
  RC_SAFE_ACCEPT(node.index);
  print_inline("])");
}

void PrettyPrintVisitor::visit(TupleExpression &node) {
  print_inline("TupleExpr(");
  for (size_t i = 0; i < node.elements.size(); ++i) {
    RC_SAFE_ACCEPT(node.elements[i]);
    if (i < node.elements.size() - 1) {
      print_inline(", ");
    }
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(BreakExpression &node) {
  print_inline("BreakExpr(");
  if (node.expr.has_value()) {
    RC_SAFE_ACCEPT(node.expr.value());
  } else {
    print_inline("None");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(ContinueExpression &node) {
  (void)node;
  print_inline("ContinueExpr");
}

void PrettyPrintVisitor::visit(PathExpression &node) {
  print_inline("PathExpr(");
  if (node.leading_colons)
    print_inline("::");
  for (size_t i = 0; i < node.segments.size(); ++i) {
    const auto &seg = node.segments[i];
    print_inline(seg.ident);
    if (seg.call.has_value()) {
      print_inline("(");
      const auto &args = seg.call->args;
      for (size_t j = 0; j < args.size(); ++j) {
        RC_SAFE_ACCEPT(args[j]);
        if (j + 1 < args.size())
          print_inline(", ");
      }
      print_inline(")");
    }
    if (i + 1 < node.segments.size())
      print_inline("::");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(QualifiedPathExpression &node) {
  print_inline("QualifiedPathExpr(");
  print_inline("base_type: " + format_type(node.base_type));
  if (node.as_type_path.has_value()) {
    print_inline(", as: ");
    const auto &tp = node.as_type_path.value();
    for (size_t i = 0; i < tp.size(); ++i) {
      print_inline(tp[i]);
      if (i + 1 < tp.size())
        print_inline("::");
    }
  }
  print_inline(", segments: ");
  PathExpression tmp(false, {});
  tmp.segments = node.segments;
  visit(tmp);
  print_inline(")");
}

// Statement visitors
void PrettyPrintVisitor::visit(BlockStatement &node) {
  print_line("BlockStmt {");
  increase_indent();
  print_line("statements: [");
  increase_indent();
  for (const auto &stmt : node.statements) {
    print_indent();
    if (stmt) {
      stmt->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }
  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(LetStatement &node) {
  print_inline("LetStmt {");
  print_inline(" pattern: ");
  // Use pattern visitors by visiting a small shim node
  if (node.pattern) {
    // We have pattern nodes that aren't BaseNode; dispatch manually
    RC_SAFE_ACCEPT(node.pattern);
  } else {
    print_inline("<none>");
  }
  print_inline(", type: " + format_type(node.type));
  print_inline(", expr: ");
  RC_SAFE_ACCEPT(node.expr);
  print_inline(" }");
}

void PrettyPrintVisitor::visit(ExpressionStatement &node) {
  print_inline("ExprStmt {");
  print_inline(" expr: ");
  RC_SAFE_ACCEPT(node.expression);
  print_inline(", semicolon: " +
               std::string(node.has_semicolon ? "true" : "false"));
  print_inline(" }");
}

void PrettyPrintVisitor::visit(EmptyStatement &node) {
  (void)node; // Suppress unused parameter warning
  print_inline("EmptyStmt");
}

// Top-level declaration visitors
void PrettyPrintVisitor::visit(FunctionDecl &node) {
  print_line("FunctionDecl {");
  increase_indent();
  print_line("name: " + node.name);

  if (node.params.has_value()) {
    print_line("params: [");
    increase_indent();
    for (const auto &param : node.params.value()) {
      print_line("(" + param.first + ": " + format_type(param.second) + ")");
    }
    decrease_indent();
    print_line("]");
  } else {
    print_line("params: None");
  }

  print_line("return_type: " + format_type(node.return_type));

  if (node.body.has_value()) {
    print_indent();
    print_inline("body: ");
    RC_SAFE_ACCEPT(node.body.value());
    output_ << std::endl;
  } else {
    print_line("body: None");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ConstantItem &node) {
  print_line("ConstantItem {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("type: " + format_type(node.type));

  if (node.value.has_value()) {
    print_indent();
    print_inline("value: ");
    RC_SAFE_ACCEPT(node.value.value());
    output_ << std::endl;
  } else {
    print_line("value: None");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ModuleDecl &node) {
  print_line("ModuleDecl {");
  increase_indent();
  print_line("name: " + node.name);

  if (node.items.has_value()) {
    print_line("items: [");
    increase_indent();
    for (const auto &item : node.items.value()) {
      print_indent();
      if (item) {
        item->accept(*this);
      } else {
        print_inline("<null>");
      }
      output_ << std::endl;
    }
    decrease_indent();
    print_line("]");
  } else {
    print_line("items: None (semicolon form)");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(StructDecl &node) {
  print_line("StructDecl {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("type: " +
             std::string(node.struct_type == StructDecl::StructType::Struct
                             ? "Struct"
                             : "Tuple"));

  if (node.struct_type == StructDecl::StructType::Struct &&
      !node.fields.empty()) {
    print_line("fields: [");
    increase_indent();
    for (const auto &field : node.fields) {
      print_line("(" + field.first + ": " + format_type(field.second) + ")");
    }
    decrease_indent();
    print_line("]");
  } else if (node.struct_type == StructDecl::StructType::Tuple &&
             !node.tuple_fields.empty()) {
    print_line("tuple_fields: [");
    increase_indent();
    for (const auto &field : node.tuple_fields) {
      print_line(format_type(field));
    }
    decrease_indent();
    print_line("]");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(EnumDecl &node) {
  print_line("EnumDecl {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("variants: [");
  increase_indent();

  for (const auto &variant : node.variants) {
    print_line("EnumVariant {");
    increase_indent();
    print_line("name: " + variant.name);

    if (variant.tuple_fields.has_value()) {
      print_line("tuple_fields: [");
      increase_indent();
      for (const auto &field : variant.tuple_fields.value()) {
        print_line(format_type(field));
      }
      decrease_indent();
      print_line("]");
    }

    if (variant.struct_fields.has_value()) {
      print_line("struct_fields: [");
      increase_indent();
      for (const auto &field : variant.struct_fields.value()) {
        print_line("(" + field.first + ": " + format_type(field.second) + ")");
      }
      decrease_indent();
      print_line("]");
    }

    if (variant.discriminant.has_value()) {
      print_indent();
      print_inline("discriminant: ");
      RC_SAFE_ACCEPT(variant.discriminant.value());
      output_ << std::endl;
    }

    decrease_indent();
    print_line("}");
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(TraitDecl &node) {
  print_line("TraitDecl {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("associated_items: [");
  increase_indent();

  for (const auto &item : node.associated_items) {
    print_indent();
    if (item) {
      item->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ImplDecl &node) {
  print_line("ImplDecl {");
  increase_indent();
  print_line("impl_type: " +
             std::string(node.impl_type == ImplDecl::ImplType::Inherent
                             ? "Inherent"
                             : "Trait"));
  print_line("target_type: " + format_type(node.target_type));

  if (node.trait_name.has_value()) {
    print_line("trait_name: " + node.trait_name.value());
  }

  print_line("associated_items: [");
  increase_indent();

  for (const auto &item : node.associated_items) {
    print_indent();
    if (item) {
      item->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(RootNode &node) {
  print_line("RootNode {");
  increase_indent();
  print_line("children: [");
  increase_indent();

  for (const auto &child : node.children) {
    print_indent();
    if (child) {
      child->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_line("}");
}

// Pattern visitors
void PrettyPrintVisitor::visit(BasePattern &node) {
  (void)node;
  print_inline("<pattern>");
}

void PrettyPrintVisitor::visit(IdentifierPattern &node) {
  print_inline("IdentifierPattern(");
  if (node.is_ref)
    print_inline("ref ");
  if (node.is_mutable)
    print_inline("mut ");
  print_inline(node.name);
  if (node.subpattern.has_value()) {
    print_inline(" @ ");
    RC_SAFE_ACCEPT(node.subpattern.value());
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(LiteralPattern &node) {
  print_inline("LiteralPattern(");
  if (node.is_negative)
    print_inline("-");
  print_inline(node.value);
  print_inline(")");
}

void PrettyPrintVisitor::visit(WildcardPattern &node) {
  (void)node;
  print_inline("WildcardPattern(_)");
}

void PrettyPrintVisitor::visit(RestPattern &node) {
  (void)node;
  print_inline("RestPattern(..)");
}

void PrettyPrintVisitor::visit(ReferencePattern &node) {
  print_inline("ReferencePattern(&");
  if (node.is_mutable)
    print_inline("mut ");
  RC_SAFE_ACCEPT(node.inner_pattern);
  print_inline(")");
}

void PrettyPrintVisitor::visit(StructPattern &node) {
  print_inline("StructPattern(");
  // print path
  for (size_t i = 0; i < node.path.size(); ++i) {
    print_inline(node.path[i]);
    if (i + 1 < node.path.size())
      print_inline("::");
  }
  print_inline(" { ");
  for (size_t i = 0; i < node.fields.size(); ++i) {
    const auto &f = node.fields[i];
    print_inline(f.name + ": ");
    RC_SAFE_ACCEPT(f.pattern);
    if (i + 1 < node.fields.size())
      print_inline(", ");
  }
  if (node.has_rest) {
    if (!node.fields.empty())
      print_inline(", ");
    print_inline("..");
  }
  print_inline(" })");
}

void PrettyPrintVisitor::visit(TuplePattern &node) {
  print_inline("TuplePattern(");
  for (size_t i = 0; i < node.elements.size(); ++i) {
    RC_SAFE_ACCEPT(node.elements[i]);
    if (i + 1 < node.elements.size())
      print_inline(", ");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(GroupedPattern &node) {
  print_inline("GroupedPattern(");
  RC_SAFE_ACCEPT(node.inner_pattern);
  print_inline(")");
}

void PrettyPrintVisitor::visit(PathPattern &node) {
  print_inline("PathPattern(");
  for (size_t i = 0; i < node.path.size(); ++i) {
    print_inline(node.path[i]);
    if (i + 1 < node.path.size())
      print_inline("::");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(SlicePattern &node) {
  print_inline("SlicePattern([");
  for (size_t i = 0; i < node.elements.size(); ++i) {
    RC_SAFE_ACCEPT(node.elements[i]);
    if (i + 1 < node.elements.size())
      print_inline(", ");
  }
  print_inline("]) ");
}

void PrettyPrintVisitor::visit(OrPattern &node) {
  print_inline("OrPattern(");
  for (size_t i = 0; i < node.alternatives.size(); ++i) {
    RC_SAFE_ACCEPT(node.alternatives[i]);
    if (i + 1 < node.alternatives.size())
      print_inline(" | ");
  }
  print_inline(")");
}

// Private helper methods
void PrettyPrintVisitor::print_indent() {
  for (int i = 0; i < indent_level_; ++i) {
    output_ << "  ";
  }
}

void PrettyPrintVisitor::increase_indent() { indent_level_++; }

void PrettyPrintVisitor::decrease_indent() {
  if (indent_level_ > 0) {
    indent_level_--;
  }
}

void PrettyPrintVisitor::print_line(const std::string &text) {
  print_indent();
  output_ << text << std::endl;
}

void PrettyPrintVisitor::print_inline(const std::string &text) {
  output_ << text;
}

std::string PrettyPrintVisitor::format_type(const LiteralType &type) {
  return to_string(type);
}

std::string PrettyPrintVisitor::format_token(const Token &token) {
  // Format token based on its type and lexeme
  std::string result = toString(token.type);
  if (!token.lexeme.empty() && token.lexeme != result) {
    result += "(" + token.lexeme + ")";
  }
  return result;
}

// Utility function
std::string pretty_print(BaseNode &node, int indent_level) {
  PrettyPrintVisitor visitor(indent_level);
  node.accept(visitor);
  return visitor.get_result();
}

} // namespace rc

#undef RC_SAFE_ACCEPT
