#include "ast/visitors/pretty_print.hpp"
#include "ast/nodes/expr.hpp"
#include "ast/nodes/pattern.hpp"
#include "lexer/lexer.hpp"
#include <typeinfo>

/**
 @note Pretty Print utility is fully generated by Claude 4 Sonnet in Agent mode
 */

#define RC_SAFE_ACCEPT(ptr)                                                    \
  do {                                                                         \
    if (ptr) {                                                                 \
      (ptr)->accept(*this);                                                    \
    } else {                                                                   \
      print_inline("<null>");                                                  \
    }                                                                          \
  } while (0)

namespace rc {

PrettyPrintVisitor::PrettyPrintVisitor(int indent_level, bool use_colors)
    : indent_level_(indent_level), use_colors_(use_colors),
      in_list_context_(false) {}

std::string PrettyPrintVisitor::get_result() const { return output_.str(); }

void PrettyPrintVisitor::reset() {
  output_.str("");
  output_.clear();
  indent_level_ = 0;
  in_list_context_ = false;
}

void PrettyPrintVisitor::visit(BaseNode &node) {
  // Try to cast to specific node types
  if (auto *expr = dynamic_cast<NameExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<LiteralExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<PrefixExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<BinaryExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<GroupExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<IfExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<MatchExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<ReturnExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<CallExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<MethodCallExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<FieldAccessExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<UnderscoreExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<BlockExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<LoopExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<WhileExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<ArrayExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<IndexExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<TupleExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<StructExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<BreakExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<ContinueExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<PathExpression *>(&node)) {
    visit(*expr);
  } else if (auto *expr = dynamic_cast<QualifiedPathExpression *>(&node)) {
    visit(*expr);
  } else if (auto *stmt = dynamic_cast<BlockStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *stmt = dynamic_cast<LetStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *stmt = dynamic_cast<ExpressionStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *stmt = dynamic_cast<EmptyStatement *>(&node)) {
    visit(*stmt);
  } else if (auto *decl = dynamic_cast<FunctionDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<ConstantItem *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<ModuleDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<StructDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<EnumDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<TraitDecl *>(&node)) {
    visit(*decl);
  } else if (auto *decl = dynamic_cast<ImplDecl *>(&node)) {
    visit(*decl);
  } else if (auto *root = dynamic_cast<RootNode *>(&node)) {
    visit(*root);
  } else {
    print_line("UnknownNode");
  }
}

// Expression visitors
void PrettyPrintVisitor::visit(NameExpression &node) {
  print_inline(node_color("NameExpr") + colorize("(", Colors::BRACE) +
               identifier_color(node.name) + colorize(")", Colors::BRACE));
}

void PrettyPrintVisitor::visit(LiteralExpression &node) {
  print_inline(node_color("LiteralExpr") + colorize("(", Colors::BRACE) +
               literal_color(node.value) + colorize(", ", Colors::SEPARATOR) +
               format_type(node.type) + colorize(")", Colors::BRACE));
}

void PrettyPrintVisitor::visit(PrefixExpression &node) {
  print_inline(node_color("PrefixExpr") + colorize("(", Colors::BRACE));
  print_inline(format_token(node.op) + colorize(", ", Colors::SEPARATOR));
  RC_SAFE_ACCEPT(node.right);
  print_inline(colorize(")", Colors::BRACE));
}

void PrettyPrintVisitor::visit(BinaryExpression &node) {
  print_inline(node_color("BinaryExpr") + colorize("(", Colors::BRACE));
  RC_SAFE_ACCEPT(node.left);
  print_inline(colorize(", ", Colors::SEPARATOR) + format_token(node.op) +
               colorize(", ", Colors::SEPARATOR));
  RC_SAFE_ACCEPT(node.right);
  print_inline(colorize(")", Colors::BRACE));
}

void PrettyPrintVisitor::visit(GroupExpression &node) {
  print_inline(node_color("GroupExpr") + colorize("(", Colors::BRACE));
  RC_SAFE_ACCEPT(node.inner);
  print_inline(colorize(")", Colors::BRACE));
}

void PrettyPrintVisitor::visit(IfExpression &node) {
  print_node_start("IfExpr");

  print_field_start("condition");
  RC_SAFE_ACCEPT(node.condition);
  print_field_end();

  print_field_start("then_block");
  RC_SAFE_ACCEPT(node.then_block);
  print_field_end();

  if (node.else_block.has_value()) {
    print_field_start("else_block");
    RC_SAFE_ACCEPT(node.else_block.value());
    print_field_end();
  }

  print_node_end();
}

void PrettyPrintVisitor::visit(CallExpression &node) {
  print_inline(node_color("CallExpr") + colorize("(", Colors::BRACE));
  RC_SAFE_ACCEPT(node.function_name);
  print_inline(colorize(", [", Colors::BRACKET));
  for (size_t i = 0; i < node.arguments.size(); ++i) {
    RC_SAFE_ACCEPT(node.arguments[i]);
    if (i < node.arguments.size() - 1) {
      print_inline(colorize(", ", Colors::SEPARATOR));
    }
  }
  print_inline(colorize("])", Colors::BRACKET) + colorize(")", Colors::BRACE));
}

void PrettyPrintVisitor::visit(MethodCallExpression &node) {
  print_inline("MethodCallExpr(");
  RC_SAFE_ACCEPT(node.receiver);
  print_inline(", " + node.method_name.name + ", [");
  for (size_t i = 0; i < node.arguments.size(); ++i) {
    RC_SAFE_ACCEPT(node.arguments[i]);
    if (i < node.arguments.size() - 1) {
      print_inline(", ");
    }
  }
  print_inline("])");
}

void PrettyPrintVisitor::visit(FieldAccessExpression &node) {
  print_inline("FieldAccessExpr(");
  RC_SAFE_ACCEPT(node.target);
  print_inline(", " + node.field_name + ")");
}

void PrettyPrintVisitor::visit(MatchExpression &node) {
  print_line("MatchExpr {");
  increase_indent();

  print_indent();
  print_inline("scrutinee: ");
  RC_SAFE_ACCEPT(node.scrutinee);
  output_ << std::endl;

  print_line("arms: [");
  increase_indent();
  for (const auto &arm : node.arms) {
    print_line("MatchArm {");
    increase_indent();
    print_line("pattern: ");
    RC_SAFE_ACCEPT(arm.pattern);
    if (arm.guard.has_value()) {
      print_indent();
      print_inline("guard: ");
      RC_SAFE_ACCEPT(arm.guard.value());
      output_ << std::endl;
    }
    print_indent();
    print_inline("body: ");
    RC_SAFE_ACCEPT(arm.body);
    output_ << std::endl;
    decrease_indent();
    print_line("}");
  }
  decrease_indent();
  print_line("]");

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ReturnExpression &node) {
  print_inline("ReturnExpr(");
  if (node.value.has_value()) {
    RC_SAFE_ACCEPT(node.value.value());
  } else {
    print_inline("None");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(UnderscoreExpression &node) {
  (void)node; // Suppress unused parameter warning
  print_inline("UnderscoreExpr");
}

void PrettyPrintVisitor::visit(BlockExpression &node) {
  print_node_start("BlockExpr");

  if (!node.statements.empty()) {
    print_list_start("statements");
    for (const auto &stmt : node.statements) {
      print_indent();
      in_list_context_ = true;
      if (stmt) {
        stmt->accept(*this);
      } else {
        print_inline(colorize("<null>", Colors::DIM));
      }
      in_list_context_ = false;
      print_newline();
    }
    print_list_end();
  }

  if (node.final_expr.has_value()) {
    print_field_start("final_expr");
    RC_SAFE_ACCEPT(node.final_expr.value());
    print_field_end();
  }

  print_node_end();
}

void PrettyPrintVisitor::visit(LoopExpression &node) {
  print_line("LoopExpr {");
  increase_indent();
  print_indent();
  print_inline("body: ");
  RC_SAFE_ACCEPT(node.body);
  output_ << std::endl;
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(WhileExpression &node) {
  print_line("WhileExpr {");
  increase_indent();
  print_indent();
  print_inline("condition: ");
  RC_SAFE_ACCEPT(node.condition);
  output_ << std::endl;
  print_indent();
  print_inline("body: ");
  RC_SAFE_ACCEPT(node.body);
  output_ << std::endl;
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ArrayExpression &node) {
  print_inline("ArrayExpr(");
  if (node.repeat.has_value()) {
    // Repeat form: [expr ; size]
    print_inline("repeat: ");
    RC_SAFE_ACCEPT(node.repeat.value().first);
    print_inline(" ; ");
    RC_SAFE_ACCEPT(node.repeat.value().second);
  } else {
    // Element list form: [e1, e2, ...]
    print_inline("elements: [");
    for (size_t i = 0; i < node.elements.size(); ++i) {
      RC_SAFE_ACCEPT(node.elements[i]);
      if (i < node.elements.size() - 1) {
        print_inline(", ");
      }
    }
    print_inline("]");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(IndexExpression &node) {
  print_inline("IndexExpr(");
  RC_SAFE_ACCEPT(node.target);
  print_inline("[");
  RC_SAFE_ACCEPT(node.index);
  print_inline("])");
}

void PrettyPrintVisitor::visit(TupleExpression &node) {
  print_inline("TupleExpr(");
  for (size_t i = 0; i < node.elements.size(); ++i) {
    RC_SAFE_ACCEPT(node.elements[i]);
    if (i < node.elements.size() - 1) {
      print_inline(", ");
    }
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(StructExpression &node) {
  print_inline("StructExpr(");
  RC_SAFE_ACCEPT(node.path_expr);
  print_inline(" { ");
  for (size_t i = 0; i < node.fields.size(); ++i) {
    const auto &f = node.fields[i];
    print_inline(f.name);
    if (f.value.has_value()) {
      print_inline(": ");
      RC_SAFE_ACCEPT(f.value.value());
    }
    if (i + 1 < node.fields.size())
      print_inline(", ");
  }
  print_inline(" }");
  print_inline(")");
}

void PrettyPrintVisitor::visit(BreakExpression &node) {
  print_inline("BreakExpr(");
  if (node.expr.has_value()) {
    RC_SAFE_ACCEPT(node.expr.value());
  } else {
    print_inline("None");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(ContinueExpression &node) {
  (void)node;
  print_inline("ContinueExpr");
}

void PrettyPrintVisitor::visit(PathExpression &node) {
  print_inline("PathExpr(");
  if (node.leading_colons)
    print_inline("::");
  for (size_t i = 0; i < node.segments.size(); ++i) {
    const auto &seg = node.segments[i];
    print_inline(seg.ident);
    if (seg.call.has_value()) {
      print_inline("(");
      const auto &args = seg.call->args;
      for (size_t j = 0; j < args.size(); ++j) {
        RC_SAFE_ACCEPT(args[j]);
        if (j + 1 < args.size())
          print_inline(", ");
      }
      print_inline(")");
    }
    if (i + 1 < node.segments.size())
      print_inline("::");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(QualifiedPathExpression &node) {
  print_inline("QualifiedPathExpr(");
  print_inline("base_type: " + format_type(node.base_type));
  if (node.as_type_path.has_value()) {
    print_inline(", as: ");
    const auto &tp = node.as_type_path.value();
    for (size_t i = 0; i < tp.size(); ++i) {
      print_inline(tp[i]);
      if (i + 1 < tp.size())
        print_inline("::");
    }
  }
  print_inline(", segments: ");
  PathExpression tmp(false, {});
  tmp.segments = node.segments;
  visit(tmp);
  print_inline(")");
}

// Statement visitors
void PrettyPrintVisitor::visit(BlockStatement &node) {
  print_line("BlockStmt {");
  increase_indent();
  print_line("statements: [");
  increase_indent();
  for (const auto &stmt : node.statements) {
    print_indent();
    if (stmt) {
      stmt->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }
  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(LetStatement &node) {
  print_inline(node_color("LetStmt") + colorize(" { ", Colors::BRACE));
  print_inline(field_color("pattern") + colorize(": ", Colors::SEPARATOR));
  if (node.pattern) {
    RC_SAFE_ACCEPT(node.pattern);
  } else {
    print_inline(colorize("<none>", Colors::DIM));
  }
  print_inline(colorize(", ", Colors::SEPARATOR) + field_color("type") +
               colorize(": ", Colors::SEPARATOR) + format_type(node.type));
  print_inline(colorize(", ", Colors::SEPARATOR) + field_color("expr") +
               colorize(": ", Colors::SEPARATOR));
  RC_SAFE_ACCEPT(node.expr);
  print_inline(colorize(" }", Colors::BRACE));
}

void PrettyPrintVisitor::visit(ExpressionStatement &node) {
  print_inline(node_color("ExprStmt") + colorize(" { ", Colors::BRACE));
  print_inline(field_color("expr") + colorize(": ", Colors::SEPARATOR));
  RC_SAFE_ACCEPT(node.expression);
  print_inline(colorize(", ", Colors::SEPARATOR) + field_color("semicolon") +
               colorize(": ", Colors::SEPARATOR) +
               literal_color(node.has_semicolon ? "true" : "false"));
  print_inline(colorize(" }", Colors::BRACE));
}

void PrettyPrintVisitor::visit(EmptyStatement &node) {
  (void)node; // Suppress unused parameter warning
  print_inline("EmptyStmt");
}

// Top-level declaration visitors
void PrettyPrintVisitor::visit(FunctionDecl &node) {
  print_node_start("FunctionDecl");

  print_field("name", identifier_color(node.name));

  if (node.params.has_value()) {
    print_list_start("params");
    for (const auto &param : node.params.value()) {
      print_indent();
      print_inline(colorize("(", Colors::BRACE));
      in_list_context_ = true;
      RC_SAFE_ACCEPT(param.first);
      in_list_context_ = false;
      print_inline(colorize(" : ", Colors::SEPARATOR) +
                   format_type(param.second) + colorize(")", Colors::BRACE));
      print_newline();
    }
    print_list_end();
  } else {
    print_field("params", colorize("None", Colors::DIM));
  }

  print_field("return_type", format_type(node.return_type));

  if (node.body.has_value()) {
    print_field_start("body");
    RC_SAFE_ACCEPT(node.body.value());
    print_field_end();
  } else {
    print_field("body", colorize("None", Colors::DIM));
  }

  print_node_end();
}

void PrettyPrintVisitor::visit(ConstantItem &node) {
  print_line("ConstantItem {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("type: " + format_type(node.type));

  if (node.value.has_value()) {
    print_indent();
    print_inline("value: ");
    RC_SAFE_ACCEPT(node.value.value());
    output_ << std::endl;
  } else {
    print_line("value: None");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ModuleDecl &node) {
  print_line("ModuleDecl {");
  increase_indent();
  print_line("name: " + node.name);

  if (node.items.has_value()) {
    print_line("items: [");
    increase_indent();
    for (const auto &item : node.items.value()) {
      print_indent();
      if (item) {
        item->accept(*this);
      } else {
        print_inline("<null>");
      }
      output_ << std::endl;
    }
    decrease_indent();
    print_line("]");
  } else {
    print_line("items: None (semicolon form)");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(StructDecl &node) {
  print_line("StructDecl {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("type: " +
             std::string(node.struct_type == StructDecl::StructType::Struct
                             ? "Struct"
                             : "Tuple"));

  if (node.struct_type == StructDecl::StructType::Struct &&
      !node.fields.empty()) {
    print_line("fields: [");
    increase_indent();
    for (const auto &field : node.fields) {
      print_line("(" + field.first + ": " + format_type(field.second) + ")");
    }
    decrease_indent();
    print_line("]");
  } else if (node.struct_type == StructDecl::StructType::Tuple &&
             !node.tuple_fields.empty()) {
    print_line("tuple_fields: [");
    increase_indent();
    for (const auto &field : node.tuple_fields) {
      print_line(format_type(field));
    }
    decrease_indent();
    print_line("]");
  }

  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(EnumDecl &node) {
  print_line("EnumDecl {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("variants: [");
  increase_indent();

  for (const auto &variant : node.variants) {
    print_line("EnumVariant {");
    increase_indent();
    print_line("name: " + variant.name);

    decrease_indent();
    print_line("}");
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(TraitDecl &node) {
  print_line("TraitDecl {");
  increase_indent();
  print_line("name: " + node.name);
  print_line("associated_items: [");
  increase_indent();

  for (const auto &item : node.associated_items) {
    print_indent();
    if (item) {
      item->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(ImplDecl &node) {
  print_line("ImplDecl {");
  increase_indent();
  print_line("impl_type: " +
             std::string(node.impl_type == ImplDecl::ImplType::Inherent
                             ? "Inherent"
                             : "Trait"));
  print_line("target_type: " + format_type(node.target_type));

  if (node.trait_name.has_value()) {
    print_line("trait_name: " + node.trait_name.value());
  }

  print_line("associated_items: [");
  increase_indent();

  for (const auto &item : node.associated_items) {
    print_indent();
    if (item) {
      item->accept(*this);
    } else {
      print_inline("<null>");
    }
    output_ << std::endl;
  }

  decrease_indent();
  print_line("]");
  decrease_indent();
  print_indent();
  print_inline("}");
}

void PrettyPrintVisitor::visit(RootNode &node) {
  print_node_start("RootNode");

  print_list_start("children");
  for (const auto &child : node.children) {
    print_indent();
    in_list_context_ = true; // Set context before visiting child
    if (child) {
      child->accept(*this);
    } else {
      print_inline(colorize("<null>", Colors::DIM));
    }
    in_list_context_ = false; // Reset context after visiting child
    print_newline();
  }
  print_list_end();

  print_node_end();
}

// Pattern visitors
void PrettyPrintVisitor::visit(BasePattern &node) {
  (void)node;
  print_inline("<pattern>");
}

void PrettyPrintVisitor::visit(IdentifierPattern &node) {
  print_inline("IdentifierPattern(");
  if (node.is_ref)
    print_inline("ref ");
  if (node.is_mutable)
    print_inline("mut ");
  print_inline(node.name);
  print_inline(")");
}

void PrettyPrintVisitor::visit(LiteralPattern &node) {
  print_inline("LiteralPattern(");
  if (node.is_negative)
    print_inline("-");
  print_inline(node.value);
  print_inline(")");
}

void PrettyPrintVisitor::visit(WildcardPattern &node) {
  (void)node;
  print_inline("WildcardPattern(_)");
}

void PrettyPrintVisitor::visit(RestPattern &node) {
  (void)node;
  print_inline("RestPattern(..)");
}

void PrettyPrintVisitor::visit(ReferencePattern &node) {
  print_inline("ReferencePattern(&");
  if (node.is_mutable)
    print_inline("mut ");
  RC_SAFE_ACCEPT(node.inner_pattern);
  print_inline(")");
}

void PrettyPrintVisitor::visit(StructPattern &node) {
  print_inline("StructPattern(");
  // print path
  for (size_t i = 0; i < node.path.size(); ++i) {
    print_inline(node.path[i]);
    if (i + 1 < node.path.size())
      print_inline("::");
  }
  print_inline(" { ");
  for (size_t i = 0; i < node.fields.size(); ++i) {
    const auto &f = node.fields[i];
    print_inline(f.name + ": ");
    RC_SAFE_ACCEPT(f.pattern);
    if (i + 1 < node.fields.size())
      print_inline(", ");
  }
  if (node.has_rest) {
    if (!node.fields.empty())
      print_inline(", ");
    print_inline("..");
  }
  print_inline(" })");
}

void PrettyPrintVisitor::visit(TuplePattern &node) {
  print_inline("TuplePattern(");
  for (size_t i = 0; i < node.elements.size(); ++i) {
    RC_SAFE_ACCEPT(node.elements[i]);
    if (i + 1 < node.elements.size())
      print_inline(", ");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(GroupedPattern &node) {
  print_inline("GroupedPattern(");
  RC_SAFE_ACCEPT(node.inner_pattern);
  print_inline(")");
}

void PrettyPrintVisitor::visit(PathPattern &node) {
  print_inline("PathPattern(");
  for (size_t i = 0; i < node.path.size(); ++i) {
    print_inline(node.path[i]);
    if (i + 1 < node.path.size())
      print_inline("::");
  }
  print_inline(")");
}

void PrettyPrintVisitor::visit(SlicePattern &node) {
  print_inline("SlicePattern([");
  for (size_t i = 0; i < node.elements.size(); ++i) {
    RC_SAFE_ACCEPT(node.elements[i]);
    if (i + 1 < node.elements.size())
      print_inline(", ");
  }
  print_inline("]) ");
}

void PrettyPrintVisitor::visit(OrPattern &node) {
  print_inline("OrPattern(");
  for (size_t i = 0; i < node.alternatives.size(); ++i) {
    RC_SAFE_ACCEPT(node.alternatives[i]);
    if (i + 1 < node.alternatives.size())
      print_inline(" | ");
  }
  print_inline(")");
}

// Private helper methods
void PrettyPrintVisitor::print_indent() {
  for (int i = 0; i < indent_level_; ++i) {
    output_ << "  ";
  }
}

void PrettyPrintVisitor::increase_indent() { indent_level_++; }

void PrettyPrintVisitor::decrease_indent() {
  if (indent_level_ > 0) {
    indent_level_--;
  }
}

void PrettyPrintVisitor::print_line(const std::string &text) {
  print_indent();
  output_ << text << std::endl;
}

void PrettyPrintVisitor::print_inline(const std::string &text) {
  output_ << text;
}

void PrettyPrintVisitor::print_newline() { output_ << std::endl; }

// Enhanced formatting methods
void PrettyPrintVisitor::print_node_start(const std::string &node_name) {
  if (!in_list_context_) {
    print_indent();
  }
  output_ << node_color(node_name) << colorize(" {", Colors::BRACE)
          << std::endl;
  increase_indent();
}

void PrettyPrintVisitor::print_node_start_inline(const std::string &node_name) {
  output_ << node_color(node_name) << colorize(" {", Colors::BRACE)
          << std::endl;
  increase_indent();
}

void PrettyPrintVisitor::print_node_end() {
  decrease_indent();
  if (!in_list_context_) {
    print_indent();
  }
  output_ << colorize("}", Colors::BRACE);
}

void PrettyPrintVisitor::print_node_end_inline() {
  decrease_indent();
  output_ << colorize("}", Colors::BRACE);
}

void PrettyPrintVisitor::print_field(const std::string &field_name,
                                     const std::string &value) {
  print_indent();
  output_ << field_color(field_name) << colorize(": ", Colors::SEPARATOR)
          << value << std::endl;
}

void PrettyPrintVisitor::print_field_start(const std::string &field_name) {
  print_indent();
  output_ << field_color(field_name) << colorize(": ", Colors::SEPARATOR);
}

void PrettyPrintVisitor::print_field_end() { output_ << std::endl; }

void PrettyPrintVisitor::print_list_start(const std::string &list_name) {
  print_indent();
  output_ << field_color(list_name) << colorize(": [", Colors::BRACKET)
          << std::endl;
  increase_indent();
}

void PrettyPrintVisitor::print_list_end() {
  decrease_indent();
  print_indent();
  output_ << colorize("]", Colors::BRACKET) << std::endl;
}

void PrettyPrintVisitor::print_list_item_start() {
  // Do nothing - let the item handle its own indentation
}

void PrettyPrintVisitor::print_list_item_end() {
  // Do nothing - let the item handle its own newlines
}

// Color helper methods
std::string PrettyPrintVisitor::colorize(const std::string &text,
                                         const std::string &color) const {
  if (!use_colors_)
    return text;
  return color + text + Colors::RESET;
}

std::string PrettyPrintVisitor::node_color(const std::string &text) const {
  return colorize(text, Colors::NODE_NAME);
}

std::string PrettyPrintVisitor::field_color(const std::string &text) const {
  return colorize(text, Colors::FIELD_NAME);
}

std::string PrettyPrintVisitor::type_color(const std::string &text) const {
  return colorize(text, Colors::TYPE_NAME);
}

std::string PrettyPrintVisitor::literal_color(const std::string &text) const {
  return colorize(text, Colors::LITERAL);
}

std::string PrettyPrintVisitor::operator_color(const std::string &text) const {
  return colorize(text, Colors::OPERATOR);
}

std::string
PrettyPrintVisitor::identifier_color(const std::string &text) const {
  return colorize(text, Colors::IDENTIFIER);
}

std::string PrettyPrintVisitor::format_type(const LiteralType &type) {
  return type_color(to_string(type));
}

std::string PrettyPrintVisitor::format_token(const Token &token) {
  // Format token based on its type and lexeme
  std::string result = toString(token.type);
  if (!token.lexeme.empty() && token.lexeme != result) {
    result += "(" + token.lexeme + ")";
  }
  return operator_color(result);
}

// Utility function
std::string pretty_print(BaseNode &node, int indent_level) {
  PrettyPrintVisitor visitor(indent_level, true);
  node.accept(visitor);
  return visitor.get_result();
}

} // namespace rc

#undef RC_SAFE_ACCEPT
