# RCompiler Whitelist: Implementable Statements and Expressions

This document is generated by GPT-5 for a `whitelist` in my RCompiler project. It defines the concrete, implementable subset of the Rust language that the RCompiler parser and type checker will support. This subset is derived from the current Rust specification, excluding features that are explicitly removed or marked as undefined behavior.

> Scope guard
> - This whitelist covers statements and expressions plus minimal lexical constraints that materially affect parsing.
> - Items, modules, traits, and other large topics follow the spec; if a construct they require is excluded here (e.g., `async`), it is likewise out-of-scope.

## What remains unknown

- Reference & Dereference

- Type traits

- Generics

## Global lexical and naming constraints

- Identifiers: ASCII only; start with A–Z or a–z, continue with A–Z, a–z, 0–9, or `_`; must not start with `_`; length ≤ 64 bytes. Unicode identifiers and raw identifiers (`r#name`) are not supported.
- Comments: non-doc comments (`//…`, `/*…*/`) only. All doc comment forms (`///`, `/**…*/`, `//!`, `/*!…*/`) are undefined behavior and thus not accepted.
- Tokens and literals:
  - Integer literals: supported with bases 2/8/10/16 and the following types only: `i32`, `u32`, `isize`, `usize` (unsuffixed integers may infer to these types only).
  - Floating-point literals: not supported (disallow `f32`, `f64` literal forms and exponent notation).
  - Character, string, raw string: supported (ASCII source; escapes per spec).
  - C string and raw C string: supported.
  - Byte/byte string/raw byte string literals: not supported in this subset.
  - Reserved tokens/guards per `tokens.md` remain disallowed.

## Statements (allowed)

1) Item declaration statements (as in a block). No `pub` and no `extern` (both out-of-scope per undefined behavior list). Items declared in blocks have block scope only.

2) `let` statements
   - Syntax: `let PATTERN (: Type)? (= EXPR | = EXPR else BLOCK)?;`
   - If no `else`: pattern must be irrefutable.
   - If `else` present: pattern may be refutable; `else` block must diverge.
   - Type inference is allowed; RCompiler must resolve to a concrete type or emit an error.

3) Expression statements
   - `ExpressionWithoutBlock;`
   - `ExpressionWithBlock` may omit trailing `;` when its type is `()`.

## Expressions (allowed)

RCompiler accepts the following expression categories. Where constraints apply, they are listed per category.

- Literal expressions
  - Character, string, raw string; C string, raw C string; integer; boolean.
  - Excluded: floating-point, byte, byte string, raw byte string literals.

- Path expressions
  - Simple paths and paths-in-expressions are allowed.
  - No turbofish syntax (`::<…>`). Generic arguments with `<…>` in paths are allowed per spec, but RCompiler may restrict semantics to the supported type set.

- Item declarations (no `pub`/`extern`)

- Pattern System

- Empty Statements

- Grouped expressions: `(expr)`.

- Arrays and indexing: `[a, b, …]`, `expr[index]`.

- Tuples and tuple indexing: `(a, b, …)`, `expr.N`.

- Struct expressions
  - Regular construction.

- Field access: `expr.field`.

- Call expressions: `f(args…)`.

- Method-call expressions: `expr.method(args…)`.

- Operator expressions
  - Borrow: `&expr`, `&mut expr`; raw borrow: `&raw const expr`, `&raw mut expr`.
  - Dereference: `*expr`.
  - Negation: `-expr`, `!expr`.
  - Arithmetic and logical binary: `+ - * / % & | ^ << >>`.
  - Comparisons: `== != < > <= >=` (require parentheses when chaining).
  - Lazy boolean: `&& ||`.
  - Casts: `expr as TypeNoBounds` (see numeric and pointer restrictions below).
  - Assignment: `lhs = rhs` (including destructuring assignment); compound assignment: `+=`, `-=`, `*=`, `/=`, `%=` , `&=`, `|=`, `^=`, `<<=`, `>>=`.

  Numeric constraints for operators and casts:
  - Only integer types `i32`, `u32`, `isize`, `usize` are supported numerically.
  - Floating-point arithmetic/casts are excluded.
  - Integer overflow semantics follow the spec (debug overflow checks may apply). Shifts must be within bit-width.
  - `as` casts permitted per spec among supported integers; `bool/char → integer` casts allowed

- Control-flow and blocks
  - Block expressions: `{ … }` (final tail expression gives value; type `()` if absent).
  - Const blocks: `const { … }`.
  - Loops: `loop { … }` and `while <conditions> { … }` (including `while let …`).
  - Break/continue: `break` and `continue` inside loops; `break expr` for `loop` values.
  - If/else: `if <conditions> { … } else { … }` (including `if let …` and condition chains with `&&`).
  - Match: `match scrutinee { arms… }` with guards.
  - Return: `return expr?`.
  - Underscore expression: `_` where accepted by the spec.

- Macro invocation expressions: `name!(… )` (by-example macros), per macros-by-example.

## Expressions (excluded)

The following are out-of-scope and must be rejected by RCompiler:

- Async/await features
  - `await` expressions; `async` blocks; `async` closures; `async fn` bodies. (Keywords `async`, `await` are undefined for this spec.)

- Closures
  - Closure expressions `|…| …` and `move |…| …` are excluded because closure types are out-of-scope in the type system for this project.

- Try-propagation (`?`) operator.

- Struct expressions
  - Functional update (`S { ..base }`). (Syntactical Sugar)

- `for` loops (iterator loops). Only `loop` and `while` are included.

- Range expressions: `a..b`, `a..`, `..b`, `..`, `a..=b`, `..=b`.

  - Unsafe blocks: `unsafe { … }` (required for raw pointer deref and other unsafe ops as per Unsafety chapter).

- Floating-point usage
  - Floating-point literals and any float-typed arithmetic or casts.

- Byte and byte string literal expressions (`b'…'`, `b"…"`, raw byte strings).

- Labelled loops/blocks not explicitly covered by the provided grammar.

## Additional notes and edge cases

- Paths and generics: turbofish `::<…>` is not supported. Generic `<…>` arguments may still occur in paths/types, but RCompiler’s type checker should only admit supported concrete types (`i32`, `u32`, `isize`, `usize`, arrays/tuples/structs/enums built from them, references, and raw pointers as needed by the spec).
- Attributes on expressions and blocks: allowed only in the specific positions permitted by the spec; attributes themselves must be from the supported set. `pub` visibility and `extern` items are not part of this subset.
- Pattern usage: `let` and `match` patterns are allowed per the spec; destructuring assignment is allowed with irrefutable patterns only.

## Quick checklist (at a glance)

Allowed statements
- [x] Item declarations (no `pub`/`extern`)
- [x] `let` (irrefutable; `else` requires divergence)
- [x] Expression statements

Allowed expressions
- [x] Literals: char, string, raw string, C string, raw C string, integer, boolean
- [x] Paths (no turbofish), grouped, arrays/indexing, tuples/tuple indexing, structs/functional update, field access
- [x] Calls and method calls
- [x] Operators: borrow/raw borrow, deref, `-`/`!`, integer-only arithmetic/bit ops, comparisons, `&&`/`||`, `as` casts (no floats), assignment and compound assignment
- [x] Ranges
- [x] Blocks, const blocks
- [x] Loops: `loop`, `while` (+ `while let`); `break`/`continue`; `break expr` from `loop`
- [x] `if`/`else` (incl. `if let`, condition chains); `match`; `return`; underscore expr
- [x] Macro invocations

Excluded
- [ ] Async/await; `async` blocks/closures/fns; `await`
- [ ] Closures
- [ ] Try (`?`)
- [ ] `for` loops
- [ ] Floating-point literals/ops; byte/byte-string literals
- [ ] Doc comments; turbofish `::<…>`; `pub`; `extern`
