#pragma once

#include <iostream>
#include <sstream>
#include <string>

#include "ast/nodes/base.hpp"
#include "ast/nodes/expr.hpp"
#include "ast/nodes/pattern.hpp"
#include "ast/nodes/stmt.hpp"
#include "ast/nodes/topLevel.hpp"
#include "ast/types.hpp"
#include "lexer/lexer.hpp"

/**
 @note Pretty Print utility is fully generated by Claude 4 Sonnet in Agent mode
 */

#define RC_SAFE_ACCEPT(ptr)                                                    \
  do {                                                                         \
    if (ptr) {                                                                 \
      (ptr)->accept(*this);                                                    \
    } else {                                                                   \
      print_inline("<null>");                                                  \
    }                                                                          \
  } while (0)

namespace rc {

// Color constants for pretty printing
namespace Colors {
const std::string RESET = "\033[0m";
const std::string BOLD = "\033[1m";
const std::string DIM = "\033[2m";

// Node type colors
const std::string NODE_NAME = "\033[1;34m";  // Bold Blue
const std::string FIELD_NAME = "\033[1;32m"; // Bold Green
const std::string TYPE_NAME = "\033[1;33m";  // Bold Yellow
const std::string LITERAL = "\033[1;35m";    // Bold Magenta
const std::string OPERATOR = "\033[1;31m";   // Bold Red
const std::string IDENTIFIER = "\033[36m";   // Cyan
const std::string KEYWORD = "\033[1;37m";    // Bold White

// Structural colors
const std::string BRACE = "\033[37m";     // White
const std::string BRACKET = "\033[37m";   // White
const std::string SEPARATOR = "\033[90m"; // Dark Gray
} // namespace Colors

class PrettyPrintVisitor : public BaseVisitor {
public:
  explicit PrettyPrintVisitor(int indent_level = 0, bool use_colors = true)
      : indent_level_(indent_level), use_colors_(use_colors),
        in_list_context_(false) {}

  // Output the pretty-printed result
  inline std::string get_result() const { return output_.str(); }

  inline void reset() {
    output_.str("");
    output_.clear();
    indent_level_ = 0;
    in_list_context_ = false;
  }

  // Enable/disable color output
  void set_colors(bool enabled) { use_colors_ = enabled; }

  // Base visitor method
  inline void visit(BaseNode &node) override {
    // Try to cast to specific node types
    if (auto *expr = dynamic_cast<NameExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<LiteralExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<PrefixExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<BinaryExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<GroupExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<IfExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<MatchExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<ReturnExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<CallExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<MethodCallExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<FieldAccessExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<UnderscoreExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<BlockExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<LoopExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<WhileExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<ArrayExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<IndexExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<TupleExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<StructExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<DerefExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<BorrowExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<BreakExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<ContinueExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<PathExpression *>(&node)) {
      visit(*expr);
    } else if (auto *expr = dynamic_cast<QualifiedPathExpression *>(&node)) {
      visit(*expr);
    } else if (auto *stmt = dynamic_cast<BlockStatement *>(&node)) {
      visit(*stmt);
    } else if (auto *stmt = dynamic_cast<LetStatement *>(&node)) {
      visit(*stmt);
    } else if (auto *stmt = dynamic_cast<ExpressionStatement *>(&node)) {
      visit(*stmt);
    } else if (auto *stmt = dynamic_cast<EmptyStatement *>(&node)) {
      visit(*stmt);
    } else if (auto *decl = dynamic_cast<FunctionDecl *>(&node)) {
      visit(*decl);
    } else if (auto *decl = dynamic_cast<ConstantItem *>(&node)) {
      visit(*decl);
    } else if (auto *decl = dynamic_cast<ModuleDecl *>(&node)) {
      visit(*decl);
    } else if (auto *decl = dynamic_cast<StructDecl *>(&node)) {
      visit(*decl);
    } else if (auto *decl = dynamic_cast<EnumDecl *>(&node)) {
      visit(*decl);
    } else if (auto *decl = dynamic_cast<TraitDecl *>(&node)) {
      visit(*decl);
    } else if (auto *decl = dynamic_cast<ImplDecl *>(&node)) {
      visit(*decl);
    } else if (auto *root = dynamic_cast<RootNode *>(&node)) {
      visit(*root);
    } else {
      print_line("UnknownNode");
    }
  }

  // Expression visitors
  inline void visit(NameExpression &node) override {
    print_inline(node_color("NameExpr") + colorize("(", Colors::BRACE) +
                 identifier_color(node.name) + colorize(")", Colors::BRACE));
  }

  inline void visit(LiteralExpression &node) override {
    print_inline(node_color("LiteralExpr") + colorize("(", Colors::BRACE) +
                 literal_color(node.value) + colorize(", ", Colors::SEPARATOR) +
                 format_type(node.type) + colorize(")", Colors::BRACE));
  }

  inline void visit(PrefixExpression &node) override {
    print_inline(node_color("PrefixExpr") + colorize("(", Colors::BRACE));
    print_inline(format_token(node.op) + colorize(", ", Colors::SEPARATOR));
    RC_SAFE_ACCEPT(node.right);
    print_inline(colorize(")", Colors::BRACE));
  }

  inline void visit(BinaryExpression &node) override {
    print_inline(node_color("BinaryExpr") + colorize("(", Colors::BRACE));
    RC_SAFE_ACCEPT(node.left);
    print_inline(colorize(", ", Colors::SEPARATOR) + format_token(node.op) +
                 colorize(", ", Colors::SEPARATOR));
    RC_SAFE_ACCEPT(node.right);
    print_inline(colorize(")", Colors::BRACE));
  }

  inline void visit(GroupExpression &node) override {
    print_inline(node_color("GroupExpr") + colorize("(", Colors::BRACE));
    RC_SAFE_ACCEPT(node.inner);
    print_inline(colorize(")", Colors::BRACE));
  }
  inline void visit(IfExpression &node) override {
    print_node_start("IfExpr");

    print_field_start("condition");
    RC_SAFE_ACCEPT(node.condition);
    print_field_end();

    print_field_start("then_block");
    RC_SAFE_ACCEPT(node.then_block);
    print_field_end();

    if (node.else_block.has_value()) {
      print_field_start("else_block");
      RC_SAFE_ACCEPT(node.else_block.value());
      print_field_end();
    }

    print_node_end();
  }

  inline void visit(MatchExpression &node) override {
    print_line("MatchExpr {");
    increase_indent();

    print_indent();
    print_inline("scrutinee: ");
    RC_SAFE_ACCEPT(node.scrutinee);
    output_ << std::endl;

    print_line("arms: [");
    increase_indent();
    for (const auto &arm : node.arms) {
      print_line("MatchArm {");
      increase_indent();
      print_line("pattern: ");
      RC_SAFE_ACCEPT(arm.pattern);
      if (arm.guard.has_value()) {
        print_indent();
        print_inline("guard: ");
        RC_SAFE_ACCEPT(arm.guard.value());
        output_ << std::endl;
      }
      print_indent();
      print_inline("body: ");
      RC_SAFE_ACCEPT(arm.body);
      output_ << std::endl;
      decrease_indent();
      print_line("}");
    }
    decrease_indent();
    print_line("]");

    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(ReturnExpression &node) override {
    print_inline("ReturnExpr(");
    if (node.value.has_value()) {
      RC_SAFE_ACCEPT(node.value.value());
    } else {
      print_inline("None");
    }
    print_inline(")");
  }

  inline void visit(CallExpression &node) override {
    print_inline(node_color("CallExpr") + colorize("(", Colors::BRACE));
    RC_SAFE_ACCEPT(node.function_name);
    print_inline(colorize(", [", Colors::BRACKET));
    for (size_t i = 0; i < node.arguments.size(); ++i) {
      RC_SAFE_ACCEPT(node.arguments[i]);
      if (i < node.arguments.size() - 1) {
        print_inline(colorize(", ", Colors::SEPARATOR));
      }
    }
    print_inline(colorize("])", Colors::BRACKET) +
                 colorize(")", Colors::BRACE));
  }

  inline void visit(MethodCallExpression &node) override {
    print_inline("MethodCallExpr(");
    RC_SAFE_ACCEPT(node.receiver);
    print_inline(", " + node.method_name.name + ", [");
    for (size_t i = 0; i < node.arguments.size(); ++i) {
      RC_SAFE_ACCEPT(node.arguments[i]);
      if (i < node.arguments.size() - 1) {
        print_inline(", ");
      }
    }
    print_inline("])");
  }
  inline void visit(FieldAccessExpression &node) override {
    print_inline("FieldAccessExpr(");
    RC_SAFE_ACCEPT(node.target);
    print_inline(", " + node.field_name + ")");
  }

  inline void visit(UnderscoreExpression &node) override {
    (void)node; // Suppress unused parameter warning
    print_inline("UnderscoreExpr");
  }

  inline void visit(BlockExpression &node) override {
    print_node_start("BlockExpr");

    if (!node.statements.empty()) {
      print_list_start("statements");
      for (const auto &stmt : node.statements) {
        print_indent();
        in_list_context_ = true;
        if (stmt) {
          stmt->accept(*this);
        } else {
          print_inline(colorize("<null>", Colors::DIM));
        }
        in_list_context_ = false;
        print_newline();
      }
      print_list_end();
    }

    if (node.final_expr.has_value()) {
      print_field_start("final_expr");
      RC_SAFE_ACCEPT(node.final_expr.value());
      print_field_end();
    }

    print_node_end();
  }

  inline void visit(LoopExpression &node) override {
    print_line("LoopExpr {");
    increase_indent();
    print_indent();
    print_inline("body: ");
    RC_SAFE_ACCEPT(node.body);
    output_ << std::endl;
    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(WhileExpression &node) override {
    print_line("WhileExpr {");
    increase_indent();
    print_indent();
    print_inline("condition: ");
    RC_SAFE_ACCEPT(node.condition);
    output_ << std::endl;
    print_indent();
    print_inline("body: ");
    RC_SAFE_ACCEPT(node.body);
    output_ << std::endl;
    decrease_indent();
    print_indent();
    print_inline("}");
  }
  inline void visit(ArrayExpression &node) override {
    print_inline("ArrayExpr(");
    if (node.repeat.has_value()) {
      // Repeat form: [expr ; size]
      print_inline("repeat: ");
      RC_SAFE_ACCEPT(node.repeat.value().first);
      print_inline(" ; ");
      RC_SAFE_ACCEPT(node.repeat.value().second);
    } else {
      // Element list form: [e1, e2, ...]
      print_inline("elements: [");
      for (size_t i = 0; i < node.elements.size(); ++i) {
        RC_SAFE_ACCEPT(node.elements[i]);
        if (i < node.elements.size() - 1) {
          print_inline(", ");
        }
      }
      print_inline("]");
    }
    print_inline(")");
  }

  inline void visit(IndexExpression &node) override {
    print_inline("IndexExpr(");
    RC_SAFE_ACCEPT(node.target);
    print_inline("[");
    RC_SAFE_ACCEPT(node.index);
    print_inline("])");
  }

  inline void visit(TupleExpression &node) override {
    print_inline("TupleExpr(");
    for (size_t i = 0; i < node.elements.size(); ++i) {
      RC_SAFE_ACCEPT(node.elements[i]);
      if (i < node.elements.size() - 1) {
        print_inline(", ");
      }
    }
    print_inline(")");
  }

  inline void visit(StructExpression &node) override {
    print_inline("StructExpr(");
    RC_SAFE_ACCEPT(node.path_expr);
    print_inline(" { ");
    for (size_t i = 0; i < node.fields.size(); ++i) {
      const auto &f = node.fields[i];
      print_inline(f.name);
      if (f.value.has_value()) {
        print_inline(": ");
        RC_SAFE_ACCEPT(f.value.value());
      }
      if (i + 1 < node.fields.size())
        print_inline(", ");
    }
    print_inline(" }");
    print_inline(")");
  }

  inline void visit(BreakExpression &node) override {
    print_inline("BreakExpr(");
    if (node.expr.has_value()) {
      RC_SAFE_ACCEPT(node.expr.value());
    } else {
      print_inline("None");
    }
    print_inline(")");
  }

  inline void visit(ContinueExpression &node) override {
    (void)node;
    print_inline("ContinueExpr");
  }
  inline void visit(PathExpression &node) override {
    print_inline("PathExpr(");
    if (node.leading_colons)
      print_inline("::");
    for (size_t i = 0; i < node.segments.size(); ++i) {
      const auto &seg = node.segments[i];
      print_inline(seg.ident);
      if (seg.call.has_value()) {
        print_inline("(");
        const auto &args = seg.call->args;
        for (size_t j = 0; j < args.size(); ++j) {
          RC_SAFE_ACCEPT(args[j]);
          if (j + 1 < args.size())
            print_inline(", ");
        }
        print_inline(")");
      }
      if (i + 1 < node.segments.size())
        print_inline("::");
    }
    print_inline(")");
  }

  inline void visit(QualifiedPathExpression &node) override {
    print_inline("QualifiedPathExpr(");
    print_inline("base_type: " + format_type(node.base_type));
    if (node.as_type_path.has_value()) {
      print_inline(", as: ");
      const auto &tp = node.as_type_path.value();
      for (size_t i = 0; i < tp.size(); ++i) {
        print_inline(tp[i]);
        if (i + 1 < tp.size())
          print_inline("::");
      }
    }
    print_inline(", segments: ");
    PathExpression tmp(false, {});
    tmp.segments = node.segments;
    visit(tmp);
    print_inline(")");
  }

  inline void visit(BorrowExpression &node) override {
    print_inline("BorrowExpr(");
    print_inline(node.is_mutable ? "mut " : "imm ");
    RC_SAFE_ACCEPT(node.right);
    print_inline(")");
  }

  inline void visit(DerefExpression &node) override {
    print_inline("DerefExpr(");
    RC_SAFE_ACCEPT(node.right);
    print_inline(")");
  }

  // Statement visitors
  inline void visit(BlockStatement &node) override {
    print_line("BlockStmt {");
    increase_indent();
    print_line("statements: [");
    increase_indent();
    for (const auto &stmt : node.statements) {
      print_indent();
      if (stmt) {
        stmt->accept(*this);
      } else {
        print_inline("<null>");
      }
      output_ << std::endl;
    }
    decrease_indent();
    print_line("]");
    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(LetStatement &node) override {
    print_inline(node_color("LetStmt") + colorize(" { ", Colors::BRACE));
    print_inline(field_color("pattern") + colorize(": ", Colors::SEPARATOR));
    if (node.pattern) {
      RC_SAFE_ACCEPT(node.pattern);
    } else {
      print_inline(colorize("<none>", Colors::DIM));
    }
    print_inline(colorize(", ", Colors::SEPARATOR) + field_color("type") +
                 colorize(": ", Colors::SEPARATOR) + format_type(node.type));
    print_inline(colorize(", ", Colors::SEPARATOR) + field_color("expr") +
                 colorize(": ", Colors::SEPARATOR));
    RC_SAFE_ACCEPT(node.expr);
    print_inline(colorize(" }", Colors::BRACE));
  }

  inline void visit(ExpressionStatement &node) override {
    print_inline(node_color("ExprStmt") + colorize(" { ", Colors::BRACE));
    print_inline(field_color("expr") + colorize(": ", Colors::SEPARATOR));
    RC_SAFE_ACCEPT(node.expression);
    print_inline(colorize(", ", Colors::SEPARATOR) + field_color("semicolon") +
                 colorize(": ", Colors::SEPARATOR) +
                 literal_color(node.has_semicolon ? "true" : "false"));
    print_inline(colorize(" }", Colors::BRACE));
  }

  inline void visit(EmptyStatement &node) override {
    (void)node; // Suppress unused parameter warning
    print_inline("EmptyStmt");
  }

  // Pattern visitors
  inline void visit(BasePattern &node) override {
    (void)node;
    print_inline("<pattern>");
  }

  inline void visit(IdentifierPattern &node) override {
    print_inline("IdentifierPattern(");
    if (node.is_ref)
      print_inline("ref ");
    if (node.is_mutable)
      print_inline("mut ");
    print_inline(node.name);
    print_inline(")");
  }

  inline void visit(LiteralPattern &node) override {
    print_inline("LiteralPattern(");
    if (node.is_negative)
      print_inline("-");
    print_inline(node.value);
    print_inline(")");
  }

  inline void visit(WildcardPattern &node) override {
    (void)node;
    print_inline("WildcardPattern(_)");
  }

  inline void visit(RestPattern &node) override {
    (void)node;
    print_inline("RestPattern(..)");
  }

  inline void visit(ReferencePattern &node) override {
    print_inline("ReferencePattern(&");
    if (node.is_mutable)
      print_inline("mut ");
    RC_SAFE_ACCEPT(node.inner_pattern);
    print_inline(")");
  }

  inline void visit(StructPattern &node) override {
    print_inline("StructPattern(");
    // print path
    for (size_t i = 0; i < node.path.size(); ++i) {
      print_inline(node.path[i]);
      if (i + 1 < node.path.size())
        print_inline("::");
    }
    print_inline(" { ");
    for (size_t i = 0; i < node.fields.size(); ++i) {
      const auto &f = node.fields[i];
      print_inline(f.name + ": ");
      RC_SAFE_ACCEPT(f.pattern);
      if (i + 1 < node.fields.size())
        print_inline(", ");
    }
    if (node.has_rest) {
      if (!node.fields.empty())
        print_inline(", ");
      print_inline("..");
    }
    print_inline(" })");
  }

  inline void visit(TuplePattern &node) override {
    print_inline("TuplePattern(");
    for (size_t i = 0; i < node.elements.size(); ++i) {
      RC_SAFE_ACCEPT(node.elements[i]);
      if (i + 1 < node.elements.size())
        print_inline(", ");
    }
    print_inline(")");
  }

  inline void visit(GroupedPattern &node) override {
    print_inline("GroupedPattern(");
    RC_SAFE_ACCEPT(node.inner_pattern);
    print_inline(")");
  }

  inline void visit(PathPattern &node) override {
    print_inline("PathPattern(");
    for (size_t i = 0; i < node.path.size(); ++i) {
      print_inline(node.path[i]);
      if (i + 1 < node.path.size())
        print_inline("::");
    }
    print_inline(")");
  }

  inline void visit(SlicePattern &node) override {
    print_inline("SlicePattern([");
    for (size_t i = 0; i < node.elements.size(); ++i) {
      RC_SAFE_ACCEPT(node.elements[i]);
      if (i + 1 < node.elements.size())
        print_inline(", ");
    }
    print_inline("]) ");
  }

  inline void visit(OrPattern &node) override {
    print_inline("OrPattern(");
    for (size_t i = 0; i < node.alternatives.size(); ++i) {
      RC_SAFE_ACCEPT(node.alternatives[i]);
      if (i + 1 < node.alternatives.size())
        print_inline(" | ");
    }
    print_inline(")");
  }

  // Top-level declaration visitors
  inline void visit(FunctionDecl &node) override {
    print_node_start("FunctionDecl");

    print_field("name", identifier_color(node.name));

    if (node.params.has_value()) {
      print_list_start("params");
      for (const auto &param : node.params.value()) {
        print_indent();
        print_inline(colorize("(", Colors::BRACE));
        in_list_context_ = true;
        RC_SAFE_ACCEPT(param.first);
        in_list_context_ = false;
        print_inline(colorize(" : ", Colors::SEPARATOR) +
                     format_type(param.second) + colorize(")", Colors::BRACE));
        print_newline();
      }
      print_list_end();
    } else {
      print_field("params", colorize("None", Colors::DIM));
    }

    print_field("return_type", format_type(node.return_type));

    if (node.body.has_value()) {
      print_field_start("body");
      RC_SAFE_ACCEPT(node.body.value());
      print_field_end();
    } else {
      print_field("body", colorize("None", Colors::DIM));
    }

    print_node_end();
  }

  inline void visit(ConstantItem &node) override {
    print_line("ConstantItem {");
    increase_indent();
    print_line("name: " + node.name);
    print_line("type: " + format_type(node.type));

    if (node.value.has_value()) {
      print_indent();
      print_inline("value: ");
      RC_SAFE_ACCEPT(node.value.value());
      output_ << std::endl;
    } else {
      print_line("value: None");
    }

    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(ModuleDecl &node) override {
    print_line("ModuleDecl {");
    increase_indent();
    print_line("name: " + node.name);

    if (node.items.has_value()) {
      print_line("items: [");
      increase_indent();
      for (const auto &item : node.items.value()) {
        print_indent();
        if (item) {
          item->accept(*this);
        } else {
          print_inline("<null>");
        }
        output_ << std::endl;
      }
      decrease_indent();
      print_line("]");
    } else {
      print_line("items: None (semicolon form)");
    }

    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(StructDecl &node) override {
    print_line("StructDecl {");
    increase_indent();
    print_line("name: " + node.name);
    print_line("type: " +
               std::string(node.struct_type == StructDecl::StructType::Struct
                               ? "Struct"
                               : "Tuple"));

    if (node.struct_type == StructDecl::StructType::Struct &&
        !node.fields.empty()) {
      print_line("fields: [");
      increase_indent();
      for (const auto &field : node.fields) {
        print_line("(" + field.first + ": " + format_type(field.second) + ")");
      }
      decrease_indent();
      print_line("]");
    } else if (node.struct_type == StructDecl::StructType::Tuple &&
               !node.tuple_fields.empty()) {
      print_line("tuple_fields: [");
      increase_indent();
      for (const auto &field : node.tuple_fields) {
        print_line(format_type(field));
      }
      decrease_indent();
      print_line("]");
    }

    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(EnumDecl &node) override {
    print_line("EnumDecl {");
    increase_indent();
    print_line("name: " + node.name);
    print_line("variants: [");
    increase_indent();

    for (const auto &variant : node.variants) {
      print_line("EnumVariant {");
      increase_indent();
      print_line("name: " + variant.name);

      decrease_indent();
      print_line("}");
    }

    decrease_indent();
    print_line("]");
    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(TraitDecl &node) override {
    print_line("TraitDecl {");
    increase_indent();
    print_line("name: " + node.name);
    print_line("associated_items: [");
    increase_indent();

    for (const auto &item : node.associated_items) {
      print_indent();
      if (item) {
        item->accept(*this);
      } else {
        print_inline("<null>");
      }
      output_ << std::endl;
    }

    decrease_indent();
    print_line("]");
    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(ImplDecl &node) override {
    print_line("ImplDecl {");
    increase_indent();
    print_line("impl_type: " +
               std::string(node.impl_type == ImplDecl::ImplType::Inherent
                               ? "Inherent"
                               : "Trait"));
    print_line("target_type: " + format_type(node.target_type));

    if (node.trait_name.has_value()) {
      print_line("trait_name: " + node.trait_name.value());
    }

    print_line("associated_items: [");
    increase_indent();

    for (const auto &item : node.associated_items) {
      print_indent();
      if (item) {
        item->accept(*this);
      } else {
        print_inline("<null>");
      }
      output_ << std::endl;
    }

    decrease_indent();
    print_line("]");
    decrease_indent();
    print_indent();
    print_inline("}");
  }

  inline void visit(RootNode &node) override {
    print_node_start("RootNode");

    print_list_start("children");
    for (const auto &child : node.children) {
      print_indent();
      in_list_context_ = true; // Set context before visiting child
      if (child) {
        child->accept(*this);
      } else {
        print_inline(colorize("<null>", Colors::DIM));
      }
      in_list_context_ = false; // Reset context after visiting child
      print_newline();
    }
    print_list_end();

    print_node_end();
  }

private:
  std::ostringstream output_;
  int indent_level_;
  bool use_colors_;
  bool in_list_context_; // Track if we're currently inside a list

  // Core printing methods
  inline void print_indent() {
    for (int i = 0; i < indent_level_; ++i) {
      output_ << "  ";
    }
  }

  inline void increase_indent() { indent_level_++; }

  inline void decrease_indent() {
    if (indent_level_ > 0) {
      indent_level_--;
    }
  }

  inline void print_line(const std::string &text) {
    print_indent();
    output_ << text << std::endl;
  }

  inline void print_inline(const std::string &text) { output_ << text; }

  inline void print_newline() { output_ << std::endl; }

  // Enhanced formatting methods
  inline void print_node_start(const std::string &node_name) {
    if (!in_list_context_) {
      print_indent();
    }
    output_ << node_color(node_name) << colorize(" {", Colors::BRACE)
            << std::endl;
    increase_indent();
  }

  inline void print_node_start_inline(const std::string &node_name) {
    output_ << node_color(node_name) << colorize(" {", Colors::BRACE)
            << std::endl;
    increase_indent();
  }

  inline void print_node_end() {
    decrease_indent();
    if (!in_list_context_) {
      print_indent();
    }
    output_ << colorize("}", Colors::BRACE);
  }

  inline void print_node_end_inline() {
    decrease_indent();
    output_ << colorize("}", Colors::BRACE);
  }

  inline void print_field(const std::string &field_name,
                          const std::string &value) {
    print_indent();
    output_ << field_color(field_name) << colorize(": ", Colors::SEPARATOR)
            << value << std::endl;
  }

  inline void print_field_start(const std::string &field_name) {
    print_indent();
    output_ << field_color(field_name) << colorize(": ", Colors::SEPARATOR);
  }

  inline void print_field_end() { output_ << std::endl; }

  inline void print_list_start(const std::string &list_name) {
    print_indent();
    output_ << field_color(list_name) << colorize(": [", Colors::BRACKET)
            << std::endl;
    increase_indent();
  }

  inline void print_list_end() {
    decrease_indent();
    print_indent();
    output_ << colorize("]", Colors::BRACKET) << std::endl;
  }

  inline void print_list_item_start() {
    // Do nothing - let the item handle its own indentation
  }

  inline void print_list_item_end() {
    // Do nothing - let the item handle its own newlines
  }

  // Color helper methods
  inline std::string colorize(const std::string &text,
                              const std::string &color) const {
    if (!use_colors_)
      return text;
    return color + text + Colors::RESET;
  }

  inline std::string node_color(const std::string &text) const {
    return colorize(text, Colors::NODE_NAME);
  }

  inline std::string field_color(const std::string &text) const {
    return colorize(text, Colors::FIELD_NAME);
  }

  inline std::string type_color(const std::string &text) const {
    return colorize(text, Colors::TYPE_NAME);
  }

  inline std::string literal_color(const std::string &text) const {
    return colorize(text, Colors::LITERAL);
  }

  inline std::string operator_color(const std::string &text) const {
    return colorize(text, Colors::OPERATOR);
  }

  inline std::string identifier_color(const std::string &text) const {
    return colorize(text, Colors::IDENTIFIER);
  }

  // Helper methods
  inline std::string format_type(const LiteralType &type) {
    return type_color(to_string(type));
  }

  inline std::string format_token(const Token &token) {
    // Format token based on its type and lexeme
    std::string result = toString(token.type);
    if (!token.lexeme.empty() && token.lexeme != result) {
      result += "(" + token.lexeme + ")";
    }
    return operator_color(result);
  }
};

// Utility function to pretty print any AST node
inline std::string pretty_print(BaseNode &node, int indent_level = 0) {
  PrettyPrintVisitor visitor(indent_level, true);
  node.accept(visitor);
  return visitor.get_result();
}

} // namespace rc

#undef RC_SAFE_ACCEPT
