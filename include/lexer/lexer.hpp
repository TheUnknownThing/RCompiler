#pragma once

#include <regex>
#include <string>
#include <type_traits>
#include <vector>

namespace rc {

// --- GENERATED By Google Gemini ---
#define X(name, str) name,
enum class TokenType {
#include "token_defs.def"
};
#undef X

#define X(name, str)                                                           \
  case TokenType::name:                                                        \
    return str;
inline const char *toString(TokenType type) {
  switch (type) {
#include "token_defs.def"
  default:
    return "!!_UNDEFINED_TOKEN_!!";
  }
}
#undef X

#define X(name, str) {str, TokenType::name},
inline TokenType fromString(const std::string &str) {
  static const std::map<std::string, TokenType> tokenMap = {
#include "token_defs.def"
  };
  auto it = tokenMap.find(str);
  if (it != tokenMap.end()) {
    return it->second;
  }
  return TokenType::UNKNOWN;
}
#undef X

inline std::ostream &operator<<(std::ostream &os, const TokenType &type) {
  os << toString(type);
  return os;
}

// --- END GENERATED By Google Gemini ---

static std::map<TokenType, std::string> tokenTypeToRegex = {
    // Strict keywords
    {TokenType::AS, R"(\bas\b)"},
    {TokenType::BREAK, R"(\bbreak\b)"},
    {TokenType::CONST, R"(\bconst\b)"},
    {TokenType::CONTINUE, R"(\bcontinue\b)"},
    {TokenType::CRATE, R"(\bcrate\b)"},
    {TokenType::ELSE, R"(\belse\b)"},
    {TokenType::ENUM, R"(\benum\b)"},
    {TokenType::EXTERN, R"(\bextern\b)"},
    {TokenType::FALSE, R"(\bfalse\b)"},
    {TokenType::FN, R"(\bfn\b)"},
    {TokenType::FOR, R"(\bfor\b)"},
    {TokenType::IF, R"(\bif\b)"},
    {TokenType::IMPL, R"(\bimpl\b)"},
    {TokenType::IN, R"(\bin\b)"},
    {TokenType::LET, R"(\blet\b)"},
    {TokenType::LOOP, R"(\bloop\b)"},
    {TokenType::MATCH, R"(\bmatch\b)"},
    {TokenType::MOD, R"(\bmod\b)"},
    {TokenType::MOVE, R"(\bmove\b)"},
    {TokenType::MUT, R"(\bmut\b)"},
    {TokenType::PUB, R"(\bpub\b)"},
    {TokenType::REF, R"(\bref\b)"},
    {TokenType::RETURN, R"(\breturn\b)"},
    {TokenType::SELF, R"(\bself\b)"},
    {TokenType::SELF_TYPE, R"(\bSelf\b)"},
    {TokenType::STATIC, R"(\bstatic\b)"},
    {TokenType::STRUCT, R"(\bstruct\b)"},
    {TokenType::SUPER, R"(\bsuper\b)"},
    {TokenType::TRAIT, R"(\btrait\b)"},
    {TokenType::TRUE, R"(\btrue\b)"},
    {TokenType::TYPE, R"(\btype\b)"},
    {TokenType::UNSAFE, R"(\bunsafe\b)"},
    {TokenType::USE, R"(\buse\b)"},
    {TokenType::WHERE, R"(\bwhere\b)"},
    {TokenType::WHILE, R"(\bwhile\b)"},
    {TokenType::ASYNC, R"(\basync\b)"},
    {TokenType::AWAIT, R"(\bawait\b)"},
    {TokenType::DYN, R"(\bdyn\b)"},

    // Reserved keywords
    {TokenType::ABSTRACT, R"(\babstract\b)"},
    {TokenType::BECOME, R"(\bbecome\b)"},
    {TokenType::BOX, R"(\bbox\b)"},
    {TokenType::DO, R"(\bdo\b)"},
    {TokenType::FINAL, R"(\bfinal\b)"},
    {TokenType::MACRO, R"(\bmacro\b)"},
    {TokenType::OVERRIDE, R"(\boverride\b)"},
    {TokenType::PRIV, R"(\bpriv\b)"},
    {TokenType::TYPEOF, R"(\btypeof\b)"},
    {TokenType::UNSIZED, R"(\bunsized\b)"},
    {TokenType::VIRTUAL, R"(\bvirtual\b)"},
    {TokenType::YIELD, R"(\byield\b)"},
    {TokenType::TRY, R"(\btry\b)"},
    {TokenType::GEN, R"(\bgen\b)"}};

static std::map<std::string, TokenType> operatorToTokenType = {
    {"+", TokenType::PLUS},
    {"-", TokenType::MINUS},
    {"*", TokenType::STAR},
    {"/", TokenType::SLASH},
    {"%", TokenType::PERCENT},
    {"&", TokenType::AMPERSAND},
    {"|", TokenType::PIPE},
    {"^", TokenType::CARET},
    {"!", TokenType::NOT},
    {"?", TokenType::QUESTION},
    {"=", TokenType::EQ},
    {"<", TokenType::LT},
    {">", TokenType::GT},
    {"<<", TokenType::SHL},
    {">>", TokenType::SHR},
    {"<<=", TokenType::SHL_EQ},
    {">>=", TokenType::SHR_EQ},
    {"=>", TokenType::FAT_ARROW},
    {"->", TokenType::ARROW},
    {"<=", TokenType::LE},
    {">=", TokenType::GE},
    {"==", TokenType::EQ},
    {"!=", TokenType::NE},
    {"&&", TokenType::AND},
    {"||", TokenType::OR},
    {"+=", TokenType::PLUS_EQ},
    {"-=", TokenType::MINUS_EQ},
    {"*=", TokenType::STAR_EQ},
    {"/=", TokenType::SLASH_EQ},
    {"%=", TokenType::PERCENT_EQ},
    {"&=", TokenType::AMPERSAND_EQ},
    {"|=", TokenType::PIPE_EQ},
    {"^=", TokenType::CARET_EQ},
};

static std::map<std::string, TokenType> punctuationToTokenType = {
    {"::", TokenType::COLON_COLON}, {"(", TokenType::L_PAREN},
    {")", TokenType::R_PAREN},      {"{", TokenType::L_BRACE},
    {"}", TokenType::R_BRACE},      {"[", TokenType::L_BRACKET},
    {"]", TokenType::R_BRACKET},    {",", TokenType::COMMA},
    {".", TokenType::DOT},          {":", TokenType::COLON},
    {";", TokenType::SEMICOLON},
};

struct Token {
  TokenType type;
  std::string lexeme;
};

class Lexer {
public:
  Lexer(const std::string &source);
  std::vector<Token> tokenize();

private:
  std::string source;
  std::vector<Token> tokens;

  void firstPass();
  bool checkWordBoundary(char c);
  bool isPunctuation(char c);
  void checkForKeywords();
  void verifyIntegerLiteral();
};

inline Lexer::Lexer(const std::string &source) : source(source) {}

inline std::vector<Token> Lexer::tokenize() {
  firstPass();
  checkForKeywords();
  return tokens;
}

inline bool Lexer::checkWordBoundary(char c) {
  if (std::isalnum(c) || c == '_') {
    return true;
  }
  return false;
}

inline bool Lexer::isPunctuation(char c) {
  return c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' ||
         c == ',' || c == '.' || c == ':' || c == ';';
}

inline void Lexer::firstPass() {
  auto push = [&](TokenType t, std::size_t beg, std::size_t end) {
    tokens.push_back({t, source.substr(beg, end - beg)});
  };

  std::size_t i = 0;
  const std::size_t n = source.size();

  while (i < n) {
    char c = source[i];

    if (std::isspace(static_cast<unsigned char>(c))) {
      ++i;
      continue;
    }

    // raw string
    if (i + 1 < n && (c == 'r' || (i + 2 < n && (c == 'b' || c == 'c') &&
                                   source[i + 1] == 'r'))) {
      TokenType tokenType = TokenType::STRING_LITERAL;
      size_t prefixLen = 1;

      if (c == 'b') {
        tokenType = TokenType::BYTE_STRING_LITERAL;
        prefixLen = 2;
      } else if (c == 'c') {
        tokenType = TokenType::C_STRING_LITERAL;
        prefixLen = 2;
      }

      size_t hashCount = 0;
      size_t pos = i + prefixLen;

      while (pos < n && source[pos] == '#') {
        ++hashCount;
        ++pos;
      }

      if (pos < n && source[pos] == '"') {
        std::size_t beg = i;
        i = pos + 1;

        while (i < n) {
          if (source[i] == '"') {
            bool closingMatch = true;
            for (size_t j = 0; j < hashCount; ++j) {
              if (i + 1 + j >= n || source[i + 1 + j] != '#') {
                closingMatch = false;
                break;
              }
            }

            if (closingMatch) {
              i = i + 1 + hashCount;
              push(tokenType, beg, i);
              break;
            }
          }
          ++i;
        }
        continue;
      }
    }

    if (i + 1 < n && (c == 'b' || c == 'c')) {
      char next = source[i + 1];

      if (c == 'b' && next == '\'') {
        std::size_t beg = i;
        i += 2;
        bool escaped = false;
        while (i < n) {
          char d = source[i++];
          if (!escaped && d == '\'')
            break;
          escaped = (!escaped && d == '\\');
        }
        push(TokenType::BYTE_LITERAL, beg, i);
        continue;
      }

      if (c == 'b' && next == '"') {
        std::size_t beg = i;
        i += 2;
        bool escaped = false;
        while (i < n) {
          char d = source[i++];
          if (!escaped && d == '"')
            break;
          escaped = (!escaped && d == '\\');
        }
        push(TokenType::BYTE_STRING_LITERAL, beg, i);
        continue;
      }

      if (c == 'c' && next == '"') {
        std::size_t beg = i;
        i += 2;
        bool escaped = false;
        while (i < n) {
          char d = source[i++];
          if (!escaped && d == '"')
            break;
          escaped = (!escaped && d == '\\');
        }
        push(TokenType::C_STRING_LITERAL, beg, i);
        continue;
      }
    }

    // string literal
    if (c == '"') {
      std::size_t beg = i++;
      bool escaped = false;
      while (i < n) {
        char d = source[i++];
        if (!escaped && d == '"')
          break;
        escaped = (!escaped && d == '\\');
      }
      push(TokenType::STRING_LITERAL, beg, i);
      continue;
    }

    // char literal
    if (c == '\'') {
      std::size_t beg = i++;
      bool escaped = false;
      while (i < n) {
        char d = source[i++];
        if (!escaped && d == '\'')
          break;
        escaped = (!escaped && d == '\\');
      }
      push(TokenType::CHAR_LITERAL, beg, i);
      continue;
    }

    // integer literal
    if (std::isdigit(static_cast<unsigned char>(c))) {
      std::size_t beg = i++;
      while (i < n && checkWordBoundary(source[i]))
        ++i;
      push(TokenType::INTEGER_LITERAL, beg, i);
      continue;
    }

    // identifier or keyword
    if (std::isalpha(static_cast<unsigned char>(c)) || c == '_') {
      std::size_t beg = i++;
      while (i < n && checkWordBoundary(source[i]))
        ++i;
      push(TokenType::NON_KEYWORD_IDENTIFIER, beg, i);
      continue;
    }

    // punctuation
    if (isPunctuation(c)) {
      auto it = punctuationToTokenType.find(std::string(1, c));
      // check for two-character punctuation
      if (i + 1 < n && isPunctuation(source[i + 1])) {
        std::string punct = source.substr(i, 2);
        auto it2 = punctuationToTokenType.find(punct);
        if (it2 != punctuationToTokenType.end()) {
          push(it2->second, i, i + 2);
          i += 2;
          continue;
        }
      }
      push(it != punctuationToTokenType.end() ? it->second : TokenType::UNKNOWN,
           i, i + 1);
      ++i;
      continue;
    }

    // operators
    bool matched = false;
    for (int len = 3; len >= 1 && !matched; --len) {
      if (i + len > n)
        continue;
      std::string op = source.substr(i, len);
      auto it = operatorToTokenType.find(op);
      if (it != operatorToTokenType.end()) {
        push(it->second, i, i + len);
        i += len;
        matched = true;
      }
    }
    if (matched)
      continue;

    // unknown token
    push(TokenType::UNKNOWN, i, i + 1);
    ++i;
  }
  push(TokenType::TOK_EOF, n, n);
}

inline void Lexer::checkForKeywords() {
  for (auto &tok : tokens) {
    if (tok.type == TokenType::NON_KEYWORD_IDENTIFIER) {
      for (const auto &[type, pattern] : tokenTypeToRegex) {
        std::regex regex(pattern);
        if (std::regex_match(tok.lexeme, regex)) {
          tok.type = type;
          break;
        }
      }
    }
  }
}

inline void Lexer::verifyIntegerLiteral() {
  for (const auto &tok : tokens) {
    if (tok.type == TokenType::INTEGER_LITERAL) {
      // Check if the integer literal is valid
      std::regex intRegex(
          R"((\b(?:0[xX][0-9a-fA-F_]+|0[oO][0-7_]+|0[bB][01_]+|\d+)(?:(i32)?|(isize)?|(u32)?|(usize)?)\b))");
      if (!std::regex_match(tok.lexeme, intRegex)) {
        throw std::runtime_error("Compile Error: Invalid integer literal '" +
                                 tok.lexeme + "' at position " +
                                 std::to_string(tok.lexeme.size()));
      }
    }
  }
}

} // namespace rc