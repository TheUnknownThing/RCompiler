#!/usr/bin/env bash

set -euo pipefail

usage() {
    echo "Usage:"
    echo "  $0 <testcase_name>"
    echo "  $0 -a | --all   # Run all comprehensive tests found in testcases/IR-1/src/"
    exit 1
}

if [ "${1:-}" = "" ]; then
    usage
fi

ALL_MODE=0
ARG="$1"
if [ "$ARG" = "-a" ] || [ "$ARG" = "--all" ]; then
    ALL_MODE=1
fi

# Resolve directories
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$ROOT_DIR"

echo "Repository root: $ROOT_DIR"
if [ "$ALL_MODE" -eq 1 ]; then
    echo "Mode: ALL tests"
else
    echo "Test case: $ARG"
fi

# Find clang (LLVM 15+)
get_clang() {
    (which clang-15 > /dev/null 2> /dev/null && echo clang-15) || \
    (which clang-16 > /dev/null 2> /dev/null && echo clang-16) || \
    (which clang-17 > /dev/null 2> /dev/null && echo clang-17) || \
    (which clang-18 > /dev/null 2> /dev/null && echo clang-18) || \
    (which clang > /dev/null 2> /dev/null && echo clang) || \
    (echo "clang not found" >&2 && exit 1)
}
CLANG=$(get_clang)
echo "Using clang: $CLANG"

# Find reimu (RISC-V simulator)
get_reimu() {
    if [ "${REIMU_BIN:-}" != "" ]; then
        if [ -x "$REIMU_BIN" ]; then
            echo "$REIMU_BIN"
            return 0
        fi
        echo "Error: REIMU_BIN is set but not executable: $REIMU_BIN" >&2
        exit 1
    fi

    local local_reimu="$ROOT_DIR/third_party/REIMU/build/linux/x86_64/release/reimu"
    if [ -x "$local_reimu" ]; then
        echo "$local_reimu"
        return 0
    fi

    if command -v reimu > /dev/null 2>&1; then
        command -v reimu
        return 0
    fi

    echo "Error: reimu not found." >&2
    echo "  Build it locally at: $ROOT_DIR/third_party/REIMU (requires xmake)" >&2
    echo "  Or set REIMU_BIN=/path/to/reimu" >&2
    exit 1
}

REIMU=$(get_reimu)
echo "Using reimu: $REIMU"

# Build project once
echo "Running: cmake --build build"
cmake --build build

RCOMPILER="./build/rcompiler"
if [ ! -x "$RCOMPILER" ]; then
    echo "Error: rcompiler not found or not executable at $RCOMPILER"
    exit 2
fi

# Prepare test list
TEST_NAMES=()
if [ "$ALL_MODE" -eq 1 ]; then
    # Find directories named comprehensive* that contain .rx files
    while IFS= read -r -d $'\0' dir; do
        basename="$(basename "$dir")"
        rx="testcases/IR-1/src/$basename/$basename.rx"
        if [ -f "$rx" ]; then
            TEST_NAMES+=( "$basename" )
        fi
    done < <(find testcases/IR-1/src -maxdepth 1 -type d -name "comprehensive*" -print0 | sort -z)
    if [ "${#TEST_NAMES[@]}" -eq 0 ]; then
        echo "No comprehensive tests found in testcases/IR-1/src/"
        exit 0
    fi
else
    TEST_NAMES=( "$ARG" )
fi

# Helpers / state
PASSED=()
FAILED=()

# Remove '@plt' suffix not supported by reimu
remove_plt() {
    # reimu doesn't understand some GNU/LLVM assembler pseudo-ops.
    # - Strip '@plt'
    # - Rewrite 'zext.b rd, rs' => 'andi rd, rs, 255'
    sed -E \
        -e 's/@plt//g' \
        -e 's/^([[:space:]]*)zext\.b[[:space:]]+([^,[:space:]]+),[[:space:]]*([^[:space:]#]+)(.*)$/\1andi\t\2, \3, 255\4/' \
        "$1" > "$2"
}

run_test() {
    local NAME="$1"
    echo
    echo "========================================"
    echo "Running test: $NAME"
    echo "========================================"

    RX_FILE="testcases/IR-1/src/$NAME/$NAME.rx"
    if [ ! -f "$RX_FILE" ]; then
        echo "Error: source file not found: $RX_FILE"
        FAILED+=( "$NAME (missing RX)" )
        return 1
    fi

    # Create and prepare tmp directory
    mkdir -p tmp
    BUILTIN_C="$ROOT_DIR/ci/files/IR/builtin.c"
    if [ ! -f "$BUILTIN_C" ]; then
        echo "Error: builtin runtime not found: $BUILTIN_C"
        FAILED+=( "$NAME (missing builtin.c)" )
        return 1
    fi
    # Generate builtin.ll from the C source. This stays in sync with the repo and
    # avoids depending on a potentially stale checked-in builtin.ll.
    "$CLANG" -S -emit-llvm --target=riscv32-unknown-unknown-elf -march=rv32im -mabi=ilp32 -O0 -fno-builtin "$BUILTIN_C" -o tmp/builtin.ll

    # Run rcompiler and capture output to tmp/output.ll
    echo "Running: $RCOMPILER $RX_FILE > tmp/output.ll"
    set +e
    "$RCOMPILER" "$RX_FILE" > tmp/output.ll
    RCOMP_RC=$?
    set -e
    if [ "$RCOMP_RC" -ne 0 ]; then
        echo "rcompiler failed (exit $RCOMP_RC)"
        FAILED+=( "$NAME (compile failed)" )
        return 1
    fi

    cd tmp

    if [ ! -f "output.ll" ]; then
        echo "Error: output.ll not found in tmp/"
        ls -la
        cd "$ROOT_DIR"
        FAILED+=( "$NAME (missing output.ll)" )
        return 1
    fi
    if [ ! -f "builtin.ll" ]; then
        echo "Error: builtin.ll not found in tmp/ (builtin compilation failed)"
        ls -la
        cd "$ROOT_DIR"
        FAILED+=( "$NAME (missing builtin.ll)" )
        return 1
    fi

    # Inject RISC-V 32-bit target info into output.ll if missing
    if ! grep -q "target datalayout" output.ll; then
        echo "Injecting RISC-V 32-bit target info into output.ll..."
        {
            echo 'target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"'
            echo 'target triple = "riscv32-unknown-unknown-elf"'
            cat output.ll
        } > output.ll.tmp && mv output.ll.tmp output.ll
    fi

    # Compile LLVM IR to RISC-V assembly. Prefer -O0 for semantic stability,
    # but retry with -O1 if reimu fails to link due to out-of-range branches.
    local OUTPUT_OPT="-O0"
    local RETRIED_WITH_O1=0
    while true; do
        echo "Compiling output.ll to RISC-V assembly with $CLANG ($OUTPUT_OPT)..."
        set +e
        $CLANG -S --target=riscv32-unknown-elf -march=rv32im -mabi=ilp32 "$OUTPUT_OPT" "output.ll" -o "output.s.source" 2>&1
        CLANG_RC=$?
        set -e
        if [ "$CLANG_RC" -ne 0 ]; then
            echo "clang failed compiling output.ll (exit $CLANG_RC)"
            cd "$ROOT_DIR"
            FAILED+=( "$NAME (clang output.ll failed)" )
            return 1
        fi

    echo "Compiling builtin.ll to RISC-V assembly with $CLANG..."
    set +e
    $CLANG -S --target=riscv32-unknown-elf -march=rv32im -mabi=ilp32 -O0 -fno-builtin "builtin.ll" -o "builtin.s.source" 2>&1
    CLANG_RC=$?
    set -e
    if [ "$CLANG_RC" -ne 0 ]; then
        echo "clang failed compiling builtin.ll (exit $CLANG_RC)"
        cd "$ROOT_DIR"
        FAILED+=( "$NAME (clang builtin.ll failed)" )
        return 1
    fi

        # Remove @plt suffix + rewrite unsupported pseudo-ops for reimu
        remove_plt "output.s.source" "test.s"
        remove_plt "builtin.s.source" "builtin.s"

    # Prepare input/output files
    INPUT_FILE="../testcases/IR-1/src/$NAME/$NAME.in"
    EXPECTED_FILE="../testcases/IR-1/src/$NAME/$NAME.out"

        # Run with reimu
        echo "Running with reimu..."
        set +e
        if [ -f "$INPUT_FILE" ]; then
            "$REIMU" -i="$INPUT_FILE" -s=8M -o="tmp.out" -f=builtin.s,test.s > "reimu_output.txt" 2> "reimu_err.txt"
        else
            "$REIMU" -s=8M -o="tmp.out" -f=builtin.s,test.s > "reimu_output.txt" 2> "reimu_err.txt"
        fi
        REIMU_RC=$?
        set -e

        if [ "$REIMU_RC" -ne 0 ]; then
            # If this is a branch-range issue, retry once at -O1 to shrink code.
            if [ "$RETRIED_WITH_O1" -eq 0 ] && grep -q "immediate out of range" reimu_err.txt; then
                echo "reimu link failed due to out-of-range branch immediate; retrying with -O1..."
                OUTPUT_OPT="-O1"
                RETRIED_WITH_O1=1
                continue
            fi

            echo "reimu exited with non-zero status ($REIMU_RC). See reimu_err.txt:"
            sed -n '1,200p' reimu_err.txt || true
            cd "$ROOT_DIR"
            FAILED+=( "$NAME (reimu exit $REIMU_RC)" )
            return 1
        fi

        break
    done

    # Compare output
    if [ -f "$EXPECTED_FILE" ]; then
        set +e
        diff -w "$EXPECTED_FILE" tmp.out >/dev/null 2>&1
        DIFF_RC=$?
        set -e
        if [ "$DIFF_RC" -ne 0 ]; then
            echo "Output differs from expected output ($EXPECTED_FILE)."
            diff -w "$EXPECTED_FILE" tmp.out || true
            cd "$ROOT_DIR"
            FAILED+=( "$NAME (output mismatch)" )
            return 1
        else
            echo "Output matches expected output."
            PASSED+=( "$NAME" )
            cd "$ROOT_DIR"
            return 0
        fi
    else
        echo "No expected output; program ran successfully."
        PASSED+=( "$NAME" )
        cd "$ROOT_DIR"
        return 0
    fi
}

# Run tests
for t in "${TEST_NAMES[@]}"; do
    if ! run_test "$t"; then
        echo "Test $t: FAILED"
    else
        echo "Test $t: PASSED"
    fi
done

# Summary
echo
echo "==================== SUMMARY ===================="
total=$(( ${#PASSED[@]} + ${#FAILED[@]} ))
echo "Total tested: $total"
echo "Passed: ${#PASSED[@]}"
echo "Failed: ${#FAILED[@]}"

if [ "${#PASSED[@]}" -gt 0 ]; then
    echo
    echo "Passed tests:"
    for p in "${PASSED[@]}"; do
        echo "  - $p"
    done
fi

if [ "${#FAILED[@]}" -gt 0 ]; then
    echo
    echo "Failed tests:"
    for f in "${FAILED[@]}"; do
        echo "  - $f"
    done
    exit 1
fi

echo
echo "All tests passed."
exit 0
